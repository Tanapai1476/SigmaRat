-- ULTIMATE MEGA Orbit Parts Script - 50 SHAPES + 26 ANIMATIONS + ULTRAKILL WINGS + RAINBOW MODE
-- Place this in StarterPlayerScripts or StarterCharacterScripts

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local player = Players.LocalPlayer
local mouse = player:GetMouse()
local camera = workspace.CurrentCamera

-- Variables
local selectionMode = false
local selectedPart = nil
local orbitingParts = {}
local orbitConnection = nil
local selectionBox = nil
local hideSelectionBox = false

-- Settings Variables
local orbitDistance = 10
local orbitSpeed = 1
local gapMode = "None"
local gapValue = 2
local orbitShape = "Circle"
local animationMode = "None"
local wireframeMode = false
local wireframeShape = "Cube"
local hammerMode = false
local hammerStatue = nil
local hammerParts = {}
local hammerConnection = nil
local hammerDepth = 3
local wingsMode = false
local wingsConnection = nil
local wingParts = {left = {}, right = {}}
local rainbowMode = false

-- Create GUI
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "OrbitPartsGUI"
screenGui.ResetOnSpawn = false
screenGui.Parent = player:WaitForChild("PlayerGui")

-- Main Frame
local mainFrame = Instance.new("Frame")
mainFrame.Name = "MainFrame"
mainFrame.Size = UDim2.new(0, 380, 0, 550)
mainFrame.Position = UDim2.new(0.5, -190, 0.5, -275)
mainFrame.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
mainFrame.BorderSizePixel = 2
mainFrame.BorderColor3 = Color3.fromRGB(255, 255, 255)
mainFrame.Active = true
mainFrame.Draggable = true
mainFrame.Parent = screenGui

-- Scroll Frame for content
local scrollFrame = Instance.new("ScrollingFrame")
scrollFrame.Name = "ScrollFrame"
scrollFrame.Size = UDim2.new(1, 0, 1, -30)
scrollFrame.Position = UDim2.new(0, 0, 0, 30)
scrollFrame.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
scrollFrame.BorderSizePixel = 0
scrollFrame.ScrollBarThickness = 6
scrollFrame.CanvasSize = UDim2.new(0, 0, 0, 3500)
scrollFrame.Parent = mainFrame

-- Title
local title = Instance.new("TextLabel")
title.Name = "Title"
title.Size = UDim2.new(1, 0, 0, 30)
title.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
title.BorderSizePixel = 0
title.Text = "ðŸŒŸ MEGA Orbit Controller ðŸŒŸ"
title.TextColor3 = Color3.fromRGB(255, 255, 255)
title.TextSize = 16
title.Font = Enum.Font.SourceSansBold
title.Parent = mainFrame

-- Helper function to create labeled textboxes
local function createLabeledTextbox(name, labelText, defaultValue, yPosition, parent)
	local label = Instance.new("TextLabel")
	label.Name = name .. "Label"
	label.Size = UDim2.new(0.9, 0, 0, 20)
	label.Position = UDim2.new(0.05, 0, 0, yPosition)
	label.BackgroundTransparency = 1
	label.Text = labelText
	label.TextColor3 = Color3.fromRGB(220, 220, 220)
	label.TextSize = 12
	label.Font = Enum.Font.SourceSans
	label.TextXAlignment = Enum.TextXAlignment.Left
	label.Parent = parent
	
	local textbox = Instance.new("TextBox")
	textbox.Name = name
	textbox.Size = UDim2.new(0.9, 0, 0, 30)
	textbox.Position = UDim2.new(0.05, 0, 0, yPosition + 22)
	textbox.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
	textbox.BorderSizePixel = 1
	textbox.BorderColor3 = Color3.fromRGB(100, 100, 100)
	textbox.Text = tostring(defaultValue)
	textbox.TextColor3 = Color3.fromRGB(255, 255, 255)
	textbox.TextSize = 14
	textbox.Font = Enum.Font.SourceSans
	textbox.ClearTextOnFocus = false
	textbox.Parent = parent
	
	return textbox
end

-- Helper function to create small buttons
local function createSmallButton(name, text, position)
	local button = Instance.new("TextButton")
	button.Name = name
	button.Size = UDim2.new(0.28, 0, 0, 26)
	button.Position = position
	button.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
	button.BorderSizePixel = 1
	button.BorderColor3 = Color3.fromRGB(100, 100, 100)
	button.Text = text
	button.TextColor3 = Color3.fromRGB(255, 255, 255)
	button.TextSize = 10
	button.Font = Enum.Font.SourceSans
	button.Parent = scrollFrame
	return button
end

-- Selection Mode Button
local selectionButton = Instance.new("TextButton")
selectionButton.Name = "SelectionButton"
selectionButton.Size = UDim2.new(0.9, 0, 0, 40)
selectionButton.Position = UDim2.new(0.05, 0, 0, 5)
selectionButton.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
selectionButton.BorderSizePixel = 1
selectionButton.BorderColor3 = Color3.fromRGB(100, 100, 100)
selectionButton.Text = "Enable Selection Mode"
selectionButton.TextColor3 = Color3.fromRGB(255, 255, 255)
selectionButton.TextSize = 14
selectionButton.Font = Enum.Font.SourceSans
selectionButton.Parent = scrollFrame

-- Selected Part Label
local selectedLabel = Instance.new("TextLabel")
selectedLabel.Name = "SelectedLabel"
selectedLabel.Size = UDim2.new(0.9, 0, 0, 30)
selectedLabel.Position = UDim2.new(0.05, 0, 0, 50)
selectedLabel.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
selectedLabel.BorderSizePixel = 1
selectedLabel.BorderColor3 = Color3.fromRGB(100, 100, 100)
selectedLabel.Text = "Selected: None"
selectedLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
selectedLabel.TextSize = 12
selectedLabel.Font = Enum.Font.SourceSans
selectedLabel.Parent = scrollFrame

-- Hide Selection Box Toggle
local hideSelectionToggle = Instance.new("TextButton")
hideSelectionToggle.Name = "HideSelectionToggle"
hideSelectionToggle.Size = UDim2.new(0.9, 0, 0, 30)
hideSelectionToggle.Position = UDim2.new(0.05, 0, 0, 85)
hideSelectionToggle.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
hideSelectionToggle.BorderSizePixel = 1
hideSelectionToggle.BorderColor3 = Color3.fromRGB(100, 100, 100)
hideSelectionToggle.Text = "Hide Selection Box: OFF"
hideSelectionToggle.TextColor3 = Color3.fromRGB(255, 255, 255)
hideSelectionToggle.TextSize = 12
hideSelectionToggle.Font = Enum.Font.SourceSans
hideSelectionToggle.Parent = scrollFrame

-- Rainbow Mode Toggle
local rainbowToggle = Instance.new("TextButton")
rainbowToggle.Name = "RainbowToggle"
rainbowToggle.Size = UDim2.new(0.9, 0, 0, 35)
rainbowToggle.Position = UDim2.new(0.05, 0, 0, 120)
rainbowToggle.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
rainbowToggle.BorderSizePixel = 1
rainbowToggle.BorderColor3 = Color3.fromRGB(100, 100, 100)
rainbowToggle.Text = "ðŸŒˆ RAINBOW COLOR SORTING: OFF"
rainbowToggle.TextColor3 = Color3.fromRGB(255, 255, 255)
rainbowToggle.TextSize = 13
rainbowToggle.Font = Enum.Font.SourceSansBold
rainbowToggle.Parent = scrollFrame

-- Orbit Distance Input
local distanceTextbox = createLabeledTextbox("DistanceTextbox", "Orbit Distance (studs):", orbitDistance, 165, scrollFrame)

-- Orbit Speed Input
local speedTextbox = createLabeledTextbox("SpeedTextbox", "Orbit Speed (studs/second):", orbitSpeed, 230, scrollFrame)

-- Gap Mode Section Label
local gapModeLabel = Instance.new("TextLabel")
gapModeLabel.Name = "GapModeLabel"
gapModeLabel.Size = UDim2.new(0.9, 0, 0, 25)
gapModeLabel.Position = UDim2.new(0.05, 0, 0, 295)
gapModeLabel.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
gapModeLabel.BorderSizePixel = 1
gapModeLabel.BorderColor3 = Color3.fromRGB(100, 100, 100)
gapModeLabel.Text = "Gap Mode: None"
gapModeLabel.TextColor3 = Color3.fromRGB(255, 255, 100)
gapModeLabel.TextSize = 13
gapModeLabel.Font = Enum.Font.SourceSansBold
gapModeLabel.Parent = scrollFrame

-- Gap Mode Buttons
local gapModeNone = createSmallButton("GapModeNone", "None", UDim2.new(0.05, 0, 0, 325))
gapModeNone.BackgroundColor3 = Color3.fromRGB(50, 100, 50)
local gapModePerPart = createSmallButton("GapModePerPart", "Gap/Part", UDim2.new(0.36, 0, 0, 325))
local gapModeBetween = createSmallButton("GapModeBetween", "Gap Between", UDim2.new(0.67, 0, 0, 325))

-- Gap Value Input
local gapTextbox = createLabeledTextbox("GapTextbox", "Gap Value (studs):", gapValue, 360, scrollFrame)

-- Orbit Shape Section (50 SHAPES!)
local shapeLabel = Instance.new("TextLabel")
shapeLabel.Name = "ShapeLabel"
shapeLabel.Size = UDim2.new(0.9, 0, 0, 25)
shapeLabel.Position = UDim2.new(0.05, 0, 0, 425)
shapeLabel.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
shapeLabel.BorderSizePixel = 1
shapeLabel.BorderColor3 = Color3.fromRGB(100, 100, 100)
shapeLabel.Text = "âœ¨ 50 ORBIT SHAPES âœ¨"
shapeLabel.TextColor3 = Color3.fromRGB(100, 255, 255)
shapeLabel.TextSize = 13
shapeLabel.Font = Enum.Font.SourceSansBold
shapeLabel.Parent = scrollFrame

-- All 50 Shape Buttons
local shapes = {
	"Circle", "Sphere", "Cube", "Spiral", "Wave", "Helix", "Figure8", "Star",
	"Pentagon", "Hexagon", "Octagon", "Diamond", "Heart", "Infinity", "Flower",
	"DNA", "Tornado", "Galaxy", "Rings", "Mobius", "Trefoil", "Torus", "Klein",
	"Hypercube", "Metatron", "Mandala", "Vortex", "Supernova", "Nebula", "BlackHole",
	"Atom", "Molecule", "Crystal", "Fractal", "Fibonacci", "GoldenSpiral", "Lissajous",
	"Butterfly", "Dragon", "Phoenix", "Serpent", "Crown", "Lotus", "Web", "Grid",
	"Tesseract", "Slinky", "Coil", "Chain", "Constellation"
}

local shapeButtons = {}
local currentY = 455
for i, shapeName in ipairs(shapes) do
	local col = (i - 1) % 3
	local row = math.floor((i - 1) / 3)
	local xPos = 0.05 + (col * 0.31)
	local yPos = currentY + (row * 30)
	
	local btn = createSmallButton("Shape"..shapeName, shapeName, UDim2.new(xPos, 0, 0, yPos))
	if shapeName == "Circle" then
		btn.BackgroundColor3 = Color3.fromRGB(50, 100, 50)
	end
	table.insert(shapeButtons, {button = btn, shape = shapeName})
end

-- Animation Mode Section (26 ANIMATIONS!)
currentY = currentY + (math.ceil(#shapes / 3) * 30) + 20
local animLabel = Instance.new("TextLabel")
animLabel.Name = "AnimLabel"
animLabel.Size = UDim2.new(0.9, 0, 0, 25)
animLabel.Position = UDim2.new(0.05, 0, 0, currentY)
animLabel.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
animLabel.BorderSizePixel = 1
animLabel.BorderColor3 = Color3.fromRGB(100, 100, 100)
animLabel.Text = "ðŸŽ­ 26 ANIMATIONS ðŸŽ­"
animLabel.TextColor3 = Color3.fromRGB(255, 150, 255)
animLabel.TextSize = 13
animLabel.Font = Enum.Font.SourceSansBold
animLabel.Parent = scrollFrame

-- All 26 Animation Buttons
local animations = {
	"None", "Pulse", "Expand", "Wobble", "Spin", "Shake", "Bounce", "Twist",
	"Orbit", "Flip", "Stretch", "Swirl", "Jitter", "Wave", "Breathe", "Flicker",
	"Rainbow", "Chaos", "Magnetic", "Repel", "Graviton", "Quantum", "Teleport",
	"Phasing", "Morph", "Kaleidoscope"
}

local animButtons = {}
currentY = currentY + 30
for i, animName in ipairs(animations) do
	local col = (i - 1) % 3
	local row = math.floor((i - 1) / 3)
	local xPos = 0.05 + (col * 0.31)
	local yPos = currentY + (row * 30)
	
	local btn = createSmallButton("Anim"..animName, animName, UDim2.new(xPos, 0, 0, yPos))
	if animName == "None" then
		btn.BackgroundColor3 = Color3.fromRGB(50, 100, 50)
	end
	table.insert(animButtons, {button = btn, anim = animName})
end

-- Wireframe Section
currentY = currentY + (math.ceil(#animations / 3) * 30) + 20
local wireframeLabel = Instance.new("TextLabel")
wireframeLabel.Name = "WireframeLabel"
wireframeLabel.Size = UDim2.new(0.9, 0, 0, 25)
wireframeLabel.Position = UDim2.new(0.05, 0, 0, currentY)
wireframeLabel.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
wireframeLabel.BorderSizePixel = 1
wireframeLabel.BorderColor3 = Color3.fromRGB(100, 100, 100)
wireframeLabel.Text = "Wireframe Mode: OFF"
wireframeLabel.TextColor3 = Color3.fromRGB(255, 100, 255)
wireframeLabel.TextSize = 13
wireframeLabel.Font = Enum.Font.SourceSansBold
wireframeLabel.Parent = scrollFrame

-- Wireframe Toggle
currentY = currentY + 30
local wireframeToggle = Instance.new("TextButton")
wireframeToggle.Name = "WireframeToggle"
wireframeToggle.Size = UDim2.new(0.9, 0, 0, 35)
wireframeToggle.Position = UDim2.new(0.05, 0, 0, currentY)
wireframeToggle.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
wireframeToggle.BorderSizePixel = 1
wireframeToggle.BorderColor3 = Color3.fromRGB(100, 100, 100)
wireframeToggle.Text = "Toggle Wireframe 3D Shapes"
wireframeToggle.TextColor3 = Color3.fromRGB(255, 255, 255)
wireframeToggle.TextSize = 13
wireframeToggle.Font = Enum.Font.SourceSansBold
wireframeToggle.Parent = scrollFrame

-- ULTRAKILL Wings Section
currentY = currentY + 45
local wingsLabel = Instance.new("TextLabel")
wingsLabel.Name = "WingsLabel"
wingsLabel.Size = UDim2.new(0.9, 0, 0, 25)
wingsLabel.Position = UDim2.new(0.05, 0, 0, currentY)
wingsLabel.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
wingsLabel.BorderSizePixel = 1
wingsLabel.BorderColor3 = Color3.fromRGB(100, 100, 100)
wingsLabel.Text = "ðŸ‘¼ ULTRAKILL WINGS: OFF"
wingsLabel.TextColor3 = Color3.fromRGB(255, 215, 0)
wingsLabel.TextSize = 13
wingsLabel.Font = Enum.Font.SourceSansBold
wingsLabel.Parent = scrollFrame

-- Wings Toggle Button
currentY = currentY + 30
local wingsToggle = Instance.new("TextButton")
wingsToggle.Name = "WingsToggle"
wingsToggle.Size = UDim2.new(0.9, 0, 0, 40)
wingsToggle.Position = UDim2.new(0.05, 0, 0, currentY)
wingsToggle.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
wingsToggle.BorderSizePixel = 1
wingsToggle.BorderColor3 = Color3.fromRGB(100, 100, 100)
wingsToggle.Text = "Create ULTRAKILL Wings"
wingsToggle.TextColor3 = Color3.fromRGB(255, 255, 255)
wingsToggle.TextSize = 13
wingsToggle.Font = Enum.Font.SourceSansBold
wingsToggle.Parent = scrollFrame

-- Hammer Mode Section
currentY = currentY + 50
local hammerLabel = Instance.new("TextLabel")
hammerLabel.Name = "HammerLabel"
hammerLabel.Size = UDim2.new(0.9, 0, 0, 25)
hammerLabel.Position = UDim2.new(0.05, 0, 0, currentY)
hammerLabel.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
hammerLabel.BorderSizePixel = 1
hammerLabel.BorderColor3 = Color3.fromRGB(100, 100, 100)
hammerLabel.Text = "Hammer Mode: OFF"
hammerLabel.TextColor3 = Color3.fromRGB(255, 200, 50)
hammerLabel.TextSize = 13
hammerLabel.Font = Enum.Font.SourceSansBold
hammerLabel.Parent = scrollFrame

-- Hammer Toggle Button
currentY = currentY + 30
local hammerToggle = Instance.new("TextButton")
hammerToggle.Name = "HammerToggle"
hammerToggle.Size = UDim2.new(0.9, 0, 0, 40)
hammerToggle.Position = UDim2.new(0.05, 0, 0, currentY)
hammerToggle.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
hammerToggle.BorderSizePixel = 1
hammerToggle.BorderColor3 = Color3.fromRGB(100, 100, 100)
hammerToggle.Text = "Create 3D Hammer (16x16x3)"
hammerToggle.TextColor3 = Color3.fromRGB(255, 255, 255)
hammerToggle.TextSize = 13
hammerToggle.Font = Enum.Font.SourceSansBold
hammerToggle.Parent = scrollFrame

-- Hammer Smash Button
currentY = currentY + 50
local hammerSmash = Instance.new("TextButton")
hammerSmash.Name = "HammerSmash"
hammerSmash.Size = UDim2.new(0.9, 0, 0, 40)
hammerSmash.Position = UDim2.new(0.05, 0, 0, currentY)
hammerSmash.BackgroundColor3 = Color3.fromRGB(100, 40, 40)
hammerSmash.BorderSizePixel = 1
hammerSmash.BorderColor3 = Color3.fromRGB(100, 100, 100)
hammerSmash.Text = "SMASH GROUND (Press M)"
hammerSmash.TextColor3 = Color3.fromRGB(255, 255, 255)
hammerSmash.TextSize = 14
hammerSmash.Font = Enum.Font.SourceSansBold
hammerSmash.Parent = scrollFrame

-- Orbit Button
currentY = currentY + 50
local orbitButton = Instance.new("TextButton")
orbitButton.Name = "OrbitButton"
orbitButton.Size = UDim2.new(0.9, 0, 0, 45)
orbitButton.Position = UDim2.new(0.05, 0, 0, currentY)
orbitButton.BackgroundColor3 = Color3.fromRGB(50, 120, 50)
orbitButton.BorderSizePixel = 1
orbitButton.BorderColor3 = Color3.fromRGB(100, 100, 100)
orbitButton.Text = "START ORBITING"
orbitButton.TextColor3 = Color3.fromRGB(255, 255, 255)
orbitButton.TextSize = 14
orbitButton.Font = Enum.Font.SourceSansBold
orbitButton.Parent = scrollFrame

-- Info Label
currentY = currentY + 55
local infoLabel = Instance.new("TextLabel")
infoLabel.Name = "InfoLabel"
infoLabel.Size = UDim2.new(0.9, 0, 0, 380)
infoLabel.Position = UDim2.new(0.05, 0, 0, currentY)
infoLabel.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
infoLabel.BorderSizePixel = 1
infoLabel.BorderColor3 = Color3.fromRGB(80, 80, 100)
infoLabel.Text = [[ðŸŒŸ MEGA ULTIMATE FEATURES ðŸŒŸ

âœ¨ 50 ORBIT SHAPES - Massive variety!
Circle, Sphere, Cube, Spiral, Wave, Helix, Figure8, Star, Pentagon, Hexagon, Octagon, Diamond, Heart, Infinity, Flower, DNA, Tornado, Galaxy, Rings, Mobius, Trefoil, Torus, Klein, Hypercube, Metatron, Mandala, Vortex, Supernova, Nebula, BlackHole, Atom, Molecule, Crystal, Fractal, Fibonacci, GoldenSpiral, Lissajous, Butterfly, Dragon, Phoenix, Serpent, Crown, Lotus, Web, Grid, Tesseract, Slinky, Coil, Chain, Constellation

ðŸŽ­ 26 ANIMATIONS - Insane variety!
Pulse, Expand, Wobble, Spin, Shake, Bounce, Twist, Orbit, Flip, Stretch, Swirl, Jitter, Wave, Breathe, Flicker, Rainbow, Chaos, Magnetic, Repel, Graviton, Quantum, Teleport, Phasing, Morph, Kaleidoscope

ðŸ‘¼ ULTRAKILL WINGS - Epic angel wings!
Wings follow you and animate smoothly

ðŸŒˆ RAINBOW COLOR SORTING - Experimental!
Auto-arranges parts by hue (keeps original colors!)
Creates natural rainbow spectrum order

ðŸ”¨ 3D HAMMER - Ground smash with explosion!]]
infoLabel.TextColor3 = Color3.fromRGB(180, 180, 200)
infoLabel.TextSize = 9
infoLabel.Font = Enum.Font.SourceSans
infoLabel.TextWrapped = true
infoLabel.TextYAlignment = Enum.TextYAlignment.Top
infoLabel.Parent = scrollFrame

-- Update canvas size
scrollFrame.CanvasSize = UDim2.new(0, 0, 0, currentY + 390)

-- Functions
local function isPartUnlocked(part)
	if not part:IsA("BasePart") then return false end
	if part.Locked then return false end
	return true
end

local function canSetNetworkOwnership(part)
	local success = pcall(function()
		part:GetNetworkOwner()
	end)
	return success
end

local function setNetworkOwnership(part)
	if canSetNetworkOwnership(part) then
		pcall(function()
			part:SetNetworkOwner(player)
		end)
	end
end

local function createSelectionBox(part)
	if selectionBox then
		selectionBox:Destroy()
	end
	
	if not hideSelectionBox then
		selectionBox = Instance.new("SelectionBox")
		selectionBox.Adornee = part
		selectionBox.Color3 = Color3.fromRGB(0, 255, 0)
		selectionBox.LineThickness = 0.05
		selectionBox.SurfaceTransparency = 0.7
		selectionBox.Parent = workspace
	end
end

local function clearSelection()
	if selectionBox then
		selectionBox:Destroy()
		selectionBox = nil
	end
	selectedPart = nil
	selectedLabel.Text = "Selected: None"
end

local function selectPart(part)
	if not isPartUnlocked(part) then
		warn("Cannot select locked part!")
		return
	end
	
	selectedPart = part
	createSelectionBox(part)
	selectedLabel.Text = "Selected: " .. part.Name
	selectionMode = false
	selectionButton.Text = "Enable Selection Mode"
	selectionButton.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
end

local function stopOrbiting()
	if orbitConnection then
		orbitConnection:Disconnect()
		orbitConnection = nil
	end
	
	for _, part in ipairs(orbitingParts) do
		if part and part.Parent then
			pcall(function()
				part:SetNetworkOwnershipAuto()
			end)
		end
	end
	
	orbitingParts = {}
	orbitButton.Text = "START ORBITING"
	orbitButton.BackgroundColor3 = Color3.fromRGB(50, 120, 50)
end

local function destroyWings()
	if wingsConnection then
		wingsConnection:Disconnect()
		wingsConnection = nil
	end
	
	for _, part in ipairs(wingParts.left) do
		if part and part.Parent then
			pcall(function()
				part:SetNetworkOwnershipAuto()
			end)
		end
	end
	
	for _, part in ipairs(wingParts.right) do
		if part and part.Parent then
			pcall(function()
				part:SetNetworkOwnershipAuto()
			end)
		end
	end
	
	wingParts = {left = {}, right = {}}
	wingsMode = false
	wingsLabel.Text = "ðŸ‘¼ ULTRAKILL WINGS: OFF"
	wingsToggle.Text = "Create ULTRAKILL Wings"
	wingsToggle.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
end

local function createWings()
	if not selectedPart or not selectedPart.Parent then
		warn("No valid part selected!")
		return
	end
	
	destroyWings()
	
	-- Collect all unlocked unanchored parts
	local allParts = {}
	for _, obj in ipairs(workspace:GetDescendants()) do
		if obj:IsA("BasePart") and obj ~= selectedPart then
			if isPartUnlocked(obj) and not obj.Anchored then
				table.insert(allParts, obj)
				setNetworkOwnership(obj)
			end
		end
	end
	
	if #allParts < 20 then
		warn("Not enough parts for wings! Need at least 20 unlocked unanchored parts.")
		return
	end
	
	-- Split parts between left and right wings
	local partsPerWing = math.floor(#allParts / 2)
	for i = 1, partsPerWing do
		table.insert(wingParts.left, allParts[i])
	end
	for i = partsPerWing + 1, #allParts do
		table.insert(wingParts.right, allParts[i])
	end
	
	wingsMode = true
	wingsLabel.Text = "ðŸ‘¼ ULTRAKILL WINGS: ON (" .. #allParts .. " parts)"
	wingsToggle.Text = "Destroy Wings"
	wingsToggle.BackgroundColor3 = Color3.fromRGB(120, 50, 50)
	
	print("âœ¨ ULTRAKILL Wings created with " .. #allParts .. " parts!")
	
	-- Wing animation loop
	local startTime = tick()
	wingsConnection = RunService.Heartbeat:Connect(function()
		if not selectedPart or not selectedPart.Parent then
			destroyWings()
			return
		end
		
		local time = tick() - startTime
		local basePos = selectedPart.Position
		local blockCFrame = selectedPart.CFrame
		
		-- Animate left wing
		for i, part in ipairs(wingParts.left) do
			if part and part.Parent then
				local progress = (i - 1) / #wingParts.left
				
				-- Wing shape: layered feathers extending outward and back
				local wingSpan = 8 + progress * 12
				local wingHeight = -2 + math.sin(progress * math.pi) * 5
				local wingDepth = -3 - progress * 4
				
				-- Flapping animation
				local flapAngle = math.sin(time * 3 + progress * 2) * 0.6
				local flapHeight = math.sin(time * 3 + progress * 2) * 2
				
				local offset = Vector3.new(
					-wingSpan * math.cos(flapAngle),
					wingHeight + flapHeight,
					wingDepth
				)
				
				local targetPos = basePos + offset
				
				-- Smooth movement
				local direction = (targetPos - part.Position)
				local distance = direction.Magnitude
				
				if distance > 0.5 then
					part.AssemblyLinearVelocity = direction.Unit * math.min(distance * 8, 40)
				else
					part.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
				end
				
				-- Gentle rotation
				part.AssemblyAngularVelocity = Vector3.new(
					math.sin(time + i) * 1,
					math.cos(time + i) * 1,
					0
				)
			end
		end
		
		-- Animate right wing (mirrored)
		for i, part in ipairs(wingParts.right) do
			if part and part.Parent then
				local progress = (i - 1) / #wingParts.right
				
				local wingSpan = 8 + progress * 12
				local wingHeight = -2 + math.sin(progress * math.pi) * 5
				local wingDepth = -3 - progress * 4
				
				local flapAngle = math.sin(time * 3 + progress * 2) * 0.6
				local flapHeight = math.sin(time * 3 + progress * 2) * 2
				
				local offset = Vector3.new(
					wingSpan * math.cos(flapAngle),
					wingHeight + flapHeight,
					wingDepth
				)
				
				local targetPos = basePos + offset
				
				local direction = (targetPos - part.Position)
				local distance = direction.Magnitude
				
				if distance > 0.5 then
					part.AssemblyLinearVelocity = direction.Unit * math.min(distance * 8, 40)
				else
					part.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
				end
				
				part.AssemblyAngularVelocity = Vector3.new(
					math.sin(time + i) * 1,
					math.cos(time + i) * 1,
					0
				)
			end
		end
	end)
end

local function destroyHammer()
	if hammerConnection then
		hammerConnection:Disconnect()
		hammerConnection = nil
	end
	
	for _, part in ipairs(hammerParts) do
		if part and part.Parent then
			pcall(function()
				part:SetNetworkOwnershipAuto()
			end)
		end
	end
	
	hammerParts = {}
	hammerMode = false
	hammerLabel.Text = "Hammer Mode: OFF"
	hammerToggle.Text = "Create Hammer (16x16x3)"
	hammerToggle.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
end

local function createHammer()
	if not selectedPart or not selectedPart.Parent then
		warn("No valid part selected!")
		return
	end
	
	destroyHammer()
	
	local allParts = {}
	for _, obj in ipairs(workspace:GetDescendants()) do
		if obj:IsA("BasePart") and obj ~= selectedPart then
			if isPartUnlocked(obj) and not obj.Anchored then
				table.insert(allParts, obj)
				setNetworkOwnership(obj)
			end
		end
	end
	
	if #allParts < 20 then
		warn("Not enough parts!")
		return
	end
	
	local hammerPositions = {}
	
	for y = 0, 11 do
		for x = -0.5, 0.5, 1 do
			for z = -1, 1, 1 do
				table.insert(hammerPositions, Vector3.new(x, y, z))
			end
		end
	end
	
	for y = 12, 15 do
		for x = -5, 4, 1 do
			for z = -1, 1, 1 do
				if z == -1 or z == 1 or x == -5 or x == 4 or y == 12 or y == 15 then
					table.insert(hammerPositions, Vector3.new(x, y, z))
				elseif (y == 13 or y == 14) and (x == -2 or x == 1) and z == 0 then
					table.insert(hammerPositions, Vector3.new(x, y, z))
				end
			end
		end
	end
	
	for i = 1, math.min(#hammerPositions, #allParts) do
		hammerParts[i] = allParts[i]
	end
	
	hammerMode = true
	hammerLabel.Text = "Hammer Mode: ON (" .. #hammerParts .. " parts)"
	hammerToggle.Text = "Destroy Hammer"
	hammerToggle.BackgroundColor3 = Color3.fromRGB(120, 50, 50)
	
	local unusedParts = {}
	for i = #hammerParts + 1, #allParts do
		table.insert(unusedParts, allParts[i])
	end
	hammerStatue = {unusedParts = unusedParts, positions = hammerPositions}
	
	local startTime = tick()
	hammerConnection = RunService.Heartbeat:Connect(function()
		if not selectedPart or not selectedPart.Parent then
			destroyHammer()
			return
		end
		
		local time = tick() - startTime
		local floatHeight = math.sin(time * 1.5) * 1.5
		local rotationAngle = math.sin(time * 0.8) * 0.15
		
		local blockCFrame = selectedPart.CFrame
		local blockRotation = blockCFrame - blockCFrame.Position
		local basePos = selectedPart.Position + blockCFrame.RightVector * 4 + Vector3.new(0, 8, 0)
		
		for i, part in ipairs(hammerParts) do
			if part and part.Parent and hammerPositions[i] then
				local offset = hammerPositions[i]
				
				local rotatedX = offset.X * math.cos(rotationAngle) - offset.Z * math.sin(rotationAngle)
				local rotatedZ = offset.X * math.sin(rotationAngle) + offset.Z * math.cos(rotationAngle)
				local rotatedOffset = Vector3.new(rotatedX, offset.Y + floatHeight, rotatedZ)
				
				local worldOffset = blockRotation * rotatedOffset
				local targetPos = basePos + worldOffset
				
				local direction = (targetPos - part.Position)
				local distance = direction.Magnitude
				
				if distance > 0.1 then
					part.AssemblyLinearVelocity = direction.Unit * math.min(distance * 10, 50)
				else
					part.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
				end
				
				part.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
			end
		end
		
		for i, part in ipairs(unusedParts) do
			if part and part.Parent then
				local angle = (i / #unusedParts) * math.pi * 2 + time * 0.5
				local radius = 12
				local orbitOffset = Vector3.new(
					math.cos(angle) * radius,
					math.sin(time * 2 + i) * 3,
					math.sin(angle) * radius
				)
				local unusedPos = basePos + blockRotation * orbitOffset
				
				local direction = (unusedPos - part.Position)
				local distance = direction.Magnitude
				
				if distance > 0.5 then
					part.AssemblyLinearVelocity = direction.Unit * math.min(distance * 5, 30)
				else
					part.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
				end
				
				part.AssemblyAngularVelocity = Vector3.new(
					math.sin(time + i) * 2,
					math.cos(time + i) * 2,
					0
				)
			end
		end
	end)
end

local function smashHammer()
	if not hammerMode or #hammerParts == 0 then
		warn("Hammer not created!")
		return
	end
	
	if not selectedPart or not selectedPart.Parent then
		warn("Selected part no longer exists!")
		return
	end
	
	print("ðŸ”¨ HAMMER SMASH! ðŸ’¥")
	
	if hammerConnection then
		hammerConnection:Disconnect()
		hammerConnection = nil
	end
	
	local smashStartTime = tick()
	local smashDuration = 2.0
	local hammerPositions = hammerStatue.positions
	local unusedParts = hammerStatue.unusedParts
	local hasExploded = false
	
	local blockCFrame = selectedPart.CFrame
	local blockRotation = blockCFrame - blockCFrame.Position
	local basePos = selectedPart.Position + blockCFrame.RightVector * 4 + Vector3.new(0, 8, 0)
	local groundPos = selectedPart.Position + Vector3.new(0, -2, 0)
	
	hammerConnection = RunService.Heartbeat:Connect(function()
		if not selectedPart or not selectedPart.Parent then
			destroyHammer()
			return
		end
		
		blockCFrame = selectedPart.CFrame
		blockRotation = blockCFrame - blockCFrame.Position
		basePos = selectedPart.Position + blockCFrame.RightVector * 4 + Vector3.new(0, 8, 0)
		groundPos = selectedPart.Position + Vector3.new(0, -2, 0)
		
		local elapsed = tick() - smashStartTime
		local progress = math.min(elapsed / smashDuration, 1)
		
		if progress < 0.25 then
			local liftProgress = progress / 0.25
			local liftHeight = liftProgress * 25
			
			for i, part in ipairs(hammerParts) do
				if part and part.Parent and hammerPositions[i] then
					local offset = hammerPositions[i]
					local worldOffset = blockRotation * Vector3.new(offset.X, offset.Y + liftHeight, offset.Z)
					local partTargetPos = basePos + worldOffset
					
					local direction = (partTargetPos - part.Position)
					part.AssemblyLinearVelocity = direction * 15
					part.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
				end
			end
			
		elseif progress < 0.65 then
			local smashProgress = (progress - 0.25) / 0.4
			local currentHeight = 25 - (smashProgress * 35)
			
			for i, part in ipairs(hammerParts) do
				if part and part.Parent and hammerPositions[i] then
					local offset = hammerPositions[i]
					local worldOffset = blockRotation * Vector3.new(offset.X, offset.Y + currentHeight, offset.Z)
					local partTargetPos = basePos + worldOffset
					
					local direction = (partTargetPos - part.Position)
					part.AssemblyLinearVelocity = direction * 30
					part.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
				end
			end
			
			if smashProgress > 0.8 and not hasExploded then
				hasExploded = true
				
				for _, part in ipairs(unusedParts) do
					if part and part.Parent then
						local directionFromImpact = (part.Position - groundPos).Unit
						local explosionForce = 200
						
						part.AssemblyLinearVelocity = directionFromImpact * explosionForce + Vector3.new(
							math.random(-40, 40),
							math.random(80, 150),
							math.random(-40, 40)
						)
						
						part.AssemblyAngularVelocity = Vector3.new(
							math.random(-25, 25),
							math.random(-25, 25),
							math.random(-25, 25)
						)
					end
				end
			end
		else
			if hammerConnection then
				hammerConnection:Disconnect()
			end
			createHammer()
		end
	end)
end

-- Position calculation for 50 shapes
local function calculatePosition(centerPos, angle, radius, height, time, index, total)
	local x, y, z = 0, 0, 0
	
	if orbitShape == "Circle" then
		x = math.cos(angle) * radius
		z = math.sin(angle) * radius
		y = height
		
	elseif orbitShape == "Sphere" then
		local phi = math.acos(1 - 2 * (index / total))
		local theta = angle
		x = radius * math.sin(phi) * math.cos(theta)
		y = radius * math.cos(phi)
		z = radius * math.sin(phi) * math.sin(theta)
		
	elseif orbitShape == "Cube" then
		local side = math.floor((index - 1) / (total / 6)) % 6
		local t = ((index - 1) % (total / 6)) / (total / 6)
		local size = radius
		
		if side == 0 then x, y, z = size, (t - 0.5) * 2 * size, math.sin(angle) * size
		elseif side == 1 then x, y, z = -size, (t - 0.5) * 2 * size, math.sin(angle) * size
		elseif side == 2 then x, y, z = (t - 0.5) * 2 * size, size, math.sin(angle) * size
		elseif side == 3 then x, y, z = (t - 0.5) * 2 * size, -size, math.sin(angle) * size
		elseif side == 4 then x, y, z = math.cos(angle) * size, (t - 0.5) * 2 * size, size
		else x, y, z = math.cos(angle) * size, (t - 0.5) * 2 * size, -size
		end
		
	elseif orbitShape == "Spiral" then
		x = math.cos(angle) * radius
		z = math.sin(angle) * radius
		y = (angle / (math.pi * 2)) * 10 + height
		
	elseif orbitShape == "Wave" then
		x = math.cos(angle) * radius
		z = math.sin(angle) * radius
		y = height + math.sin(angle * 3 + time * 2) * 5
		
	elseif orbitShape == "Helix" then
		x = math.cos(angle) * radius * 0.7
		z = math.sin(angle) * radius * 0.7
		y = (angle / (math.pi * 2)) * 15 - 7.5
		
	elseif orbitShape == "Figure8" then
		local scale = radius / 10
		x = math.sin(angle) * 10 * scale
		z = math.sin(angle * 2) * 10 * scale
		y = height
		
	elseif orbitShape == "Star" then
		local points = 5
		local r = (math.floor(angle * points / math.pi) % 2 == 0) and radius or radius * 0.5
		x = math.cos(angle) * r
		z = math.sin(angle) * r
		y = height
		
	elseif orbitShape == "Pentagon" then
		local perfectAngle = (math.floor(index % 5) / 5) * math.pi * 2
		x = math.cos(perfectAngle) * radius
		z = math.sin(perfectAngle) * radius
		y = height
		
	elseif orbitShape == "Hexagon" then
		local perfectAngle = (math.floor(index % 6) / 6) * math.pi * 2
		x = math.cos(perfectAngle) * radius
		z = math.sin(perfectAngle) * radius
		y = height
		
	elseif orbitShape == "Octagon" then
		local perfectAngle = (math.floor(index % 8) / 8) * math.pi * 2
		x = math.cos(perfectAngle) * radius
		z = math.sin(perfectAngle) * radius
		y = height
		
	elseif orbitShape == "Diamond" then
		local t = (index / total) * 4
		local section = math.floor(t)
		local progress = t - section
		
		if section == 0 then x, y = progress * radius, (1 - progress) * radius * 1.5
		elseif section == 1 then x, y = (1 - progress) * radius, -progress * radius * 1.5
		elseif section == 2 then x, y = -progress * radius, -(1 - progress) * radius * 1.5
		else x, y = -(1 - progress) * radius, progress * radius * 1.5
		end
		z = 0
		y = y + height
		
	elseif orbitShape == "Heart" then
		x = 16 * math.sin(angle)^3 * (radius / 20)
		z = (13 * math.cos(angle) - 5 * math.cos(2*angle) - 2 * math.cos(3*angle) - math.cos(4*angle)) * (radius / 20)
		y = height
		
	elseif orbitShape == "Infinity" then
		local scale = radius / 3
		x = scale * math.cos(angle) / (1 + math.sin(angle)^2)
		z = scale * math.cos(angle) * math.sin(angle) / (1 + math.sin(angle)^2)
		y = height
		
	elseif orbitShape == "Flower" then
		local r = radius * math.cos(6 * angle)
		x = r * math.cos(angle)
		z = r * math.sin(angle)
		y = height
		
	elseif orbitShape == "DNA" then
		local strand = (index % 2 == 0) and 1 or -1
		x = math.cos(angle + strand * math.pi) * radius * 0.5
		z = math.sin(angle + strand * math.pi) * radius * 0.5
		y = (angle / (math.pi * 2)) * 20 - 10
		
	elseif orbitShape == "Tornado" then
		local heightPos = (index / total) * 15 - 7.5
		local radiusAtHeight = radius * (1 - math.abs(heightPos) / 10)
		x = math.cos(angle + heightPos * 0.5) * radiusAtHeight
		z = math.sin(angle + heightPos * 0.5) * radiusAtHeight
		y = heightPos + height
		
	elseif orbitShape == "Galaxy" then
		local spiralAngle = angle + (index / total) * math.pi * 8
		local spiralRadius = radius * (0.3 + (index / total) * 0.7)
		x = math.cos(spiralAngle) * spiralRadius
		z = math.sin(spiralAngle) * spiralRadius
		y = height + math.sin(spiralAngle * 2) * 2
		
	elseif orbitShape == "Rings" then
		local ringIndex = math.floor((index - 1) / (total / 3))
		local ringRadius = radius * (0.5 + ringIndex * 0.3)
		x = math.cos(angle) * ringRadius
		z = math.sin(angle) * ringRadius
		y = height + ringIndex * 3
		
	elseif orbitShape == "Mobius" then
		local u = angle
		local v = ((index / total) - 0.5) * 0.4
		x = (radius * 0.8 + v * math.cos(u / 2)) * math.cos(u)
		y = v * math.sin(u / 2) + height
		z = (radius * 0.8 + v * math.cos(u / 2)) * math.sin(u)
		
	-- NEW 30 SHAPES START HERE!
	elseif orbitShape == "Trefoil" then
		-- Trefoil knot
		x = (math.sin(angle) + 2 * math.sin(2 * angle)) * radius * 0.3
		y = (math.cos(angle) - 2 * math.cos(2 * angle)) * radius * 0.3 + height
		z = -math.sin(3 * angle) * radius * 0.3
		
	elseif orbitShape == "Torus" then
		local majorR = radius * 0.7
		local minorR = radius * 0.3
		local u = angle
		local v = (index / total) * math.pi * 2
		x = (majorR + minorR * math.cos(v)) * math.cos(u)
		y = minorR * math.sin(v) + height
		z = (majorR + minorR * math.cos(v)) * math.sin(u)
		
	elseif orbitShape == "Klein" then
		-- Klein bottle
		local u = angle
		local v = (index / total) * math.pi * 2
		local r = 4 * (1 - math.cos(u) / 2)
		x = (6 * math.cos(u) * (1 + math.sin(u)) + r * math.cos(v + math.pi)) * radius * 0.1
		y = (16 * math.sin(u) + r * math.sin(v)) * radius * 0.1 + height
		z = r * math.cos(v) * radius * 0.1
		
	elseif orbitShape == "Hypercube" then
		-- 4D hypercube projected to 3D
		local w = math.sin(time * 0.5)
		local corners = {
			Vector3.new(1,1,1), Vector3.new(1,1,-1), Vector3.new(1,-1,1), Vector3.new(1,-1,-1),
			Vector3.new(-1,1,1), Vector3.new(-1,1,-1), Vector3.new(-1,-1,1), Vector3.new(-1,-1,-1)
		}
		local corner = corners[(index % 8) + 1]
		x = corner.X * radius * (1 + w * 0.3)
		y = corner.Y * radius * (1 + w * 0.3) + height
		z = corner.Z * radius * (1 + w * 0.3)
		
	elseif orbitShape == "Metatron" then
		-- Metatron's cube pattern
		local layer = math.floor((index - 1) / 6) % 3
		local pos = (index - 1) % 6
		local layerRadius = radius * (0.3 + layer * 0.3)
		local layerAngle = pos / 6 * math.pi * 2
		x = math.cos(layerAngle) * layerRadius
		z = math.sin(layerAngle) * layerRadius
		y = height + layer * 2 - 2
		
	elseif orbitShape == "Mandala" then
		-- Sacred mandala pattern
		local rings = 5
		local ring = math.floor((index - 1) / (total / rings)) % rings
		local ringRadius = radius * ((ring + 1) / rings)
		local petalAngle = angle + math.sin(ring * angle) * 0.5
		x = math.cos(petalAngle) * ringRadius
		z = math.sin(petalAngle) * ringRadius
		y = height + math.sin(ring + time) * 2
		
	elseif orbitShape == "Vortex" then
		-- Swirling vortex
		local depth = (index / total) * 15
		local swirl = angle + depth * 0.3
		local vortexRadius = radius * (1 - depth / 20)
		x = math.cos(swirl) * vortexRadius
		z = math.sin(swirl) * vortexRadius
		y = -depth + height
		
	elseif orbitShape == "Supernova" then
		-- Exploding supernova pattern
		local burst = math.sin(time * 2) * 0.5 + 1
		local rays = 12
		local rayAngle = math.floor(angle * rays / (math.pi * 2)) * (math.pi * 2 / rays)
		local rayDist = radius * burst * (0.5 + (index / total) * 0.5)
		x = math.cos(rayAngle) * rayDist
		z = math.sin(rayAngle) * rayDist
		y = height + math.random(-3, 3)
		
	elseif orbitShape == "Nebula" then
		-- Nebula cloud formation
		local cloudAngle = angle + math.sin(angle * 3) * 0.8
		local cloudRadius = radius * (0.7 + math.random() * 0.6)
		x = math.cos(cloudAngle) * cloudRadius
		z = math.sin(cloudAngle) * cloudRadius
		y = height + math.sin(angle * 5) * 4
		
	elseif orbitShape == "BlackHole" then
		-- Black hole gravitational lens effect
		local eventHorizon = radius * 0.2
		local distance = eventHorizon + (index / total) * radius * 0.8
		local distortAngle = angle + (1 / distance) * 2
		x = math.cos(distortAngle) * distance
		z = math.sin(distortAngle) * distance
		y = height + math.sin(angle * 10) * (distance / radius) * 2
		
	elseif orbitShape == "Atom" then
		-- Atomic orbital patterns
		local orbital = (index % 3)
		local orbitAngle = angle + orbital * (math.pi * 2 / 3)
		local tilt = orbital * math.pi / 3
		x = math.cos(orbitAngle) * radius
		y = math.sin(orbitAngle) * radius * math.sin(tilt) + height
		z = math.sin(orbitAngle) * radius * math.cos(tilt)
		
	elseif orbitShape == "Molecule" then
		-- Molecular structure
		local nodes = 6
		local node = math.floor((index - 1) / (total / nodes)) % nodes
		local nodeAngle = node / nodes * math.pi * 2
		local bond = (index % (total / nodes)) / (total / nodes)
		x = math.cos(nodeAngle) * radius * (0.5 + bond * 0.5)
		z = math.sin(nodeAngle) * radius * (0.5 + bond * 0.5)
		y = height + math.sin(bond * math.pi) * 3
		
	elseif orbitShape == "Crystal" then
		-- Crystal lattice structure
		local layers = 5
		local layer = math.floor((index - 1) / (total / layers)) % layers
		local sides = 6
		local side = (index - 1) % sides
		x = math.cos(side / sides * math.pi * 2) * radius * (0.5 + layer * 0.1)
		z = math.sin(side / sides * math.pi * 2) * radius * (0.5 + layer * 0.1)
		y = layer * 2 + height - 4
		
	elseif orbitShape == "Fractal" then
		-- Sierpinski-inspired fractal
		local iterations = 4
		local iter = (index % iterations)
		local scale = math.pow(0.5, iter)
		x = math.cos(angle + iter) * radius * scale
		z = math.sin(angle + iter) * radius * scale
		y = height + iter * 3
		
	elseif orbitShape == "Fibonacci" then
		-- Fibonacci spiral
		local golden = (1 + math.sqrt(5)) / 2
		local fibAngle = index * golden * math.pi * 2
		local fibRadius = math.sqrt(index) * radius * 0.3
		x = math.cos(fibAngle) * fibRadius
		z = math.sin(fibAngle) * fibRadius
		y = height
		
	elseif orbitShape == "GoldenSpiral" then
		-- Golden ratio spiral
		local golden = (1 + math.sqrt(5)) / 2
		local progress = angle / (math.pi * 2)
		local spiralRadius = radius * math.pow(golden, progress * 2 - 1)
		x = math.cos(angle) * spiralRadius
		z = math.sin(angle) * spiralRadius
		y = height + progress * 5
		
	elseif orbitShape == "Lissajous" then
		-- Lissajous curve
		local a, b = 3, 4
		x = math.sin(a * angle + time) * radius
		y = math.cos(b * angle) * radius + height
		z = math.sin((a + b) * angle * 0.5) * radius * 0.5
		
	elseif orbitShape == "Butterfly" then
		-- Butterfly curve
		local t = angle
		local scale = radius * 0.1
		x = scale * math.sin(t) * (math.exp(math.cos(t)) - 2 * math.cos(4*t) - math.sin(t/12)^5)
		z = scale * math.cos(t) * (math.exp(math.cos(t)) - 2 * math.cos(4*t) - math.sin(t/12)^5)
		y = height
		
	elseif orbitShape == "Dragon" then
		-- Dragon curve approximation
		local segments = 8
		local seg = math.floor((index - 1) / (total / segments)) % segments
		local turn = (seg % 2 == 0) and 1 or -1
		local dragonAngle = angle + seg * math.pi / 4 * turn
		x = math.cos(dragonAngle) * radius * (seg / segments)
		z = math.sin(dragonAngle) * radius * (seg / segments)
		y = height + seg * 1.5
		
	elseif orbitShape == "Phoenix" then
		-- Phoenix wings rising
		local wing = (index % 2 == 0) and 1 or -1
		local wingSpread = (index / total) * radius
		local rise = math.sin((index / total) * math.pi) * radius * 0.8
		x = wing * wingSpread * math.cos(angle * 0.5)
		z = wingSpread * math.sin(angle)
		y = height + rise
		
	elseif orbitShape == "Serpent" then
		-- Serpentine wave
		local segments = 10
		local progress = (index / total)
		local serpentAngle = progress * math.pi * 4
		x = math.cos(angle) * radius
		z = math.sin(angle) * radius
		y = height + math.sin(serpentAngle + time * 2) * 5
		
	elseif orbitShape == "Crown" then
		-- Royal crown with peaks
		local peaks = 8
		local peak = math.floor(angle / (math.pi * 2 / peaks))
		local peakHeight = (peak % 2 == 0) and radius * 0.3 or 0
		x = math.cos(angle) * radius
		z = math.sin(angle) * radius
		y = height + peakHeight + 3
		
	elseif orbitShape == "Lotus" then
		-- Lotus flower petals
		local petals = 8
		local petal = (index % petals)
		local petalAngle = petal / petals * math.pi * 2
		local petalRadius = radius * (0.5 + math.sin(angle * 3 + petal) * 0.5)
		x = math.cos(petalAngle) * petalRadius
		z = math.sin(petalAngle) * petalRadius
		y = height + math.sin((index / total) * math.pi) * 3
		
	elseif orbitShape == "Web" then
		-- Spider web pattern
		local rings = 6
		local ring = math.floor((index - 1) / (total / rings)) % rings
		local spokes = 8
		local spoke = angle * spokes / (math.pi * 2)
		local webRadius = radius * ((ring + 1) / rings)
		x = math.cos(angle) * webRadius
		z = math.sin(angle) * webRadius
		y = height + math.sin(spoke) * 1
		
	elseif orbitShape == "Grid" then
		-- 3D Grid formation
		local gridSize = math.ceil(math.pow(total, 1/3))
		local ix = (index - 1) % gridSize
		local iy = math.floor((index - 1) / gridSize) % gridSize
		local iz = math.floor((index - 1) / (gridSize * gridSize))
		local spacing = (radius * 2) / gridSize
		x = (ix - gridSize/2) * spacing
		y = (iy - gridSize/2) * spacing + height
		z = (iz - gridSize/2) * spacing
		
	elseif orbitShape == "Tesseract" then
		-- 4D tesseract rotation
		local w1 = math.sin(time * 0.5)
		local w2 = math.cos(time * 0.5)
		local corners = 16
		local corner = (index - 1) % corners
		local ix = (corner % 2) * 2 - 1
		local iy = (math.floor(corner / 2) % 2) * 2 - 1
		local iz = (math.floor(corner / 4) % 2) * 2 - 1
		local iw = (math.floor(corner / 8) % 2) * 2 - 1
		x = ix * radius * (1 + iw * w1 * 0.3)
		y = iy * radius * (1 + iw * w2 * 0.3) + height
		z = iz * radius * (1 + iw * w1 * 0.3)
		
	elseif orbitShape == "Slinky" then
		-- Slinky coil
		local coils = 5
		local coilProgress = (index / total) * coils
		local coilAngle = coilProgress * math.pi * 2
		x = math.cos(coilAngle) * radius * 0.6
		z = math.sin(coilAngle) * radius * 0.6
		y = height + coilProgress * 3 - 7.5
		
	elseif orbitShape == "Coil" then
		-- Tight electromagnetic coil
		local turns = 20
		local turnProgress = (index / total) * turns
		x = math.cos(turnProgress * math.pi * 2) * radius * 0.5
		z = math.sin(turnProgress * math.pi * 2) * radius * 0.5
		y = height + (turnProgress / turns) * 15 - 7.5
		
	elseif orbitShape == "Chain" then
		-- Chain link pattern
		local links = 8
		local link = math.floor((index - 1) / (total / links)) % links
		local linkAngle = link / links * math.pi * 2
		local linkPos = (index % (total / links)) / (total / links)
		local linkRadius = radius * (0.8 + math.sin(linkPos * math.pi * 2) * 0.2)
		x = math.cos(linkAngle) * linkRadius
		z = math.sin(linkAngle) * linkRadius
		y = height + math.sin(linkPos * math.pi) * 2
		
	elseif orbitShape == "Constellation" then
		-- Star constellation pattern
		local clusters = 5
		local cluster = math.floor((index - 1) / (total / clusters)) % clusters
		local clusterAngle = cluster / clusters * math.pi * 2
		local starDist = radius * (0.3 + math.random() * 0.7)
		local starAngle = angle + math.random() * math.pi * 0.5
		x = math.cos(clusterAngle + starAngle) * starDist
		z = math.sin(clusterAngle + starAngle) * starDist
		y = height + math.random(-3, 3)
	end
	
	return centerPos + Vector3.new(x, y, z)
end

-- Apply animations (26 total!)
local function applyAnimation(part, targetPos, centerPos, time, index, total, phaseOffset)
	if animationMode == "None" then
		return targetPos
		
	elseif animationMode == "Pulse" then
		local pulse = 1 + math.sin(time * 3 + phaseOffset) * 0.3
		local direction = (targetPos - centerPos).Unit
		return centerPos + direction * (targetPos - centerPos).Magnitude * pulse
		
	elseif animationMode == "Expand" then
		local expand = 1 + math.sin(time * 1.5) * 0.5
		local direction = (targetPos - centerPos).Unit
		return centerPos + direction * (targetPos - centerPos).Magnitude * expand
		
	elseif animationMode == "Wobble" then
		local wobble = Vector3.new(
			math.sin(time * 4 + phaseOffset) * 2,
			math.cos(time * 3 + phaseOffset) * 2,
			math.sin(time * 3.5 + phaseOffset) * 2
		)
		return targetPos + wobble
		
	elseif animationMode == "Spin" then
		part.AssemblyAngularVelocity = Vector3.new(
			math.sin(time * 2) * 5,
			10,
			math.cos(time * 2) * 5
		)
		return targetPos
		
	elseif animationMode == "Shake" then
		local shake = Vector3.new(
			math.random(-1, 1) * 0.5,
			math.random(-1, 1) * 0.5,
			math.random(-1, 1) * 0.5
		)
		return targetPos + shake
		
	elseif animationMode == "Bounce" then
		local bounce = math.abs(math.sin(time * 5 + phaseOffset)) * 5
		return targetPos + Vector3.new(0, bounce, 0)
		
	elseif animationMode == "Twist" then
		local twistAngle = math.sin(time * 2) * 0.5
		local direction = (targetPos - centerPos)
		local distance = direction.Magnitude
		local currentAngle = math.atan2(direction.Z, direction.X)
		local newAngle = currentAngle + twistAngle
		return centerPos + Vector3.new(
			math.cos(newAngle) * distance,
			direction.Y,
			math.sin(newAngle) * distance
		)
		
	elseif animationMode == "Orbit" then
		local orbitRadius = 2
		local orbitAngle = time * 3 + phaseOffset
		local orbitOffset = Vector3.new(
			math.cos(orbitAngle) * orbitRadius,
			math.sin(orbitAngle * 1.5) * orbitRadius,
			math.sin(orbitAngle) * orbitRadius
		)
		return targetPos + orbitOffset
		
	elseif animationMode == "Flip" then
		part.AssemblyAngularVelocity = Vector3.new(
			15 * math.sin(time + phaseOffset),
			5,
			15 * math.cos(time + phaseOffset)
		)
		return targetPos
		
	elseif animationMode == "Stretch" then
		local stretch = 1 + math.sin(time * 2 + phaseOffset) * 0.6
		local direction = (targetPos - centerPos).Unit
		local baseDistance = (targetPos - centerPos).Magnitude
		return centerPos + direction * baseDistance * stretch
		
	elseif animationMode == "Swirl" then
		local swirlAngle = time * 2
		local direction = (targetPos - centerPos)
		local distance = direction.Magnitude
		local currentAngle = math.atan2(direction.Z, direction.X)
		local newAngle = currentAngle + swirlAngle * 0.3
		return centerPos + Vector3.new(
			math.cos(newAngle) * distance,
			direction.Y + math.sin(time * 3 + phaseOffset) * 4,
			math.sin(newAngle) * distance
		)
		
	elseif animationMode == "Jitter" then
		local jitter = 1.5
		local jitterSpeed = 15
		local jitterOffset = Vector3.new(
			math.sin(time * jitterSpeed + phaseOffset) * jitter,
			math.cos(time * jitterSpeed * 1.3 + phaseOffset) * jitter,
			math.sin(time * jitterSpeed * 0.8 + phaseOffset) * jitter
		)
		return targetPos + jitterOffset
		
	elseif animationMode == "Wave" then
		local waveOffset = math.sin(time * 3 - (index / total) * math.pi * 2) * 5
		return targetPos + Vector3.new(0, waveOffset, 0)
		
	-- NEW 12 ANIMATIONS START HERE!
	elseif animationMode == "Breathe" then
		local breathe = 1 + math.sin(time * 1.2 + phaseOffset) * 0.4
		local breath = math.sin(time * 1.2) * 0.2
		local direction = (targetPos - centerPos).Unit
		return centerPos + direction * (targetPos - centerPos).Magnitude * breathe + Vector3.new(0, breath * 3, 0)
		
	elseif animationMode == "Flicker" then
		local flicker = (math.sin(time * 20 + phaseOffset) > 0.5) and 1 or 0.5
		local direction = (targetPos - centerPos).Unit
		return centerPos + direction * (targetPos - centerPos).Magnitude * flicker
		
	elseif animationMode == "Rainbow" then
		-- Rainbow color cycling (handled separately in color sorting)
		local rainbowWave = math.sin(time * 2 - (index / total) * math.pi * 4) * 2
		return targetPos + Vector3.new(0, rainbowWave, 0)
		
	elseif animationMode == "Chaos" then
		local chaos = Vector3.new(
			math.sin(time * 7 + phaseOffset * 3) * 4,
			math.cos(time * 5 + phaseOffset * 2) * 4,
			math.sin(time * 9 + phaseOffset * 4) * 4
		)
		part.AssemblyAngularVelocity = Vector3.new(
			math.random(-10, 10),
			math.random(-10, 10),
			math.random(-10, 10)
		)
		return targetPos + chaos
		
	elseif animationMode == "Magnetic" then
		-- Pull towards center then push away
		local magnetic = math.sin(time * 2) * 0.7
		local direction = (targetPos - centerPos).Unit
		return centerPos + direction * (targetPos - centerPos).Magnitude * (1 + magnetic)
		
	elseif animationMode == "Repel" then
		-- Push away from center
		local repel = 1 + math.abs(math.sin(time * 2 + phaseOffset)) * 0.8
		local direction = (targetPos - centerPos).Unit
		return centerPos + direction * (targetPos - centerPos).Magnitude * repel
		
	elseif animationMode == "Graviton" then
		-- Gravitational wave effect
		local wave1 = math.sin(time * 2 + (index / total) * math.pi * 8) * 3
		local wave2 = math.cos(time * 2 + (index / total) * math.pi * 8) * 3
		return targetPos + Vector3.new(wave1, wave2, 0)
		
	elseif animationMode == "Quantum" then
		-- Quantum tunneling effect (random teleportation)
		if math.random() > 0.95 then
			local randomOffset = Vector3.new(
				math.random(-5, 5),
				math.random(-5, 5),
				math.random(-5, 5)
			)
			return targetPos + randomOffset
		end
		return targetPos
		
	elseif animationMode == "Teleport" then
		-- Periodic teleportation
		local teleportCycle = math.floor(time * 2) % 2
		if teleportCycle == 1 then
			local teleportOffset = Vector3.new(
				math.sin(index + time * 10) * 3,
				math.cos(index + time * 10) * 3,
				math.sin(index * 2 + time * 10) * 3
			)
			return targetPos + teleportOffset
		end
		return targetPos
		
	elseif animationMode == "Phasing" then
		-- Phase in and out of existence
		local phase = math.abs(math.sin(time * 3 + phaseOffset))
		local direction = (targetPos - centerPos).Unit
		return centerPos + direction * (targetPos - centerPos).Magnitude * (0.3 + phase * 0.7)
		
	elseif animationMode == "Morph" then
		-- Morph between different patterns
		local morphCycle = math.floor(time / 3) % 3
		local morphProgress = (time % 3) / 3
		
		if morphCycle == 0 then
			-- Circular
			local blend = math.sin(morphProgress * math.pi)
			return targetPos * (1 - blend) + (centerPos + Vector3.new(
				math.cos(index / total * math.pi * 2) * 10,
				0,
				math.sin(index / total * math.pi * 2) * 10
			)) * blend
		elseif morphCycle == 1 then
			-- Spherical
			return targetPos
		else
			-- Cubic
			return targetPos
		end
		
	elseif animationMode == "Kaleidoscope" then
		-- Kaleidoscope mirror effect
		local sectors = 6
		local sector = math.floor((index - 1) / (total / sectors)) % sectors
		local mirror = (sector % 2 == 0) and 1 or -1
		local kaleidoAngle = time * 2
		local direction = (targetPos - centerPos)
		local rotated = Vector3.new(
			direction.X * math.cos(kaleidoAngle) - direction.Z * math.sin(kaleidoAngle),
			direction.Y + math.sin(time * 4 + phaseOffset) * 2,
			direction.X * math.sin(kaleidoAngle) + direction.Z * math.cos(kaleidoAngle)
		)
		return centerPos + rotated * mirror
	end
	
	return targetPos
end

local function startOrbiting()
	if not selectedPart or not selectedPart.Parent then
		warn("No valid part selected!")
		return
	end
	
	stopOrbiting()
	
	orbitDistance = tonumber(distanceTextbox.Text) or 10
	orbitSpeed = tonumber(speedTextbox.Text) or 1
	gapValue = tonumber(gapTextbox.Text) or 2
	
	for _, obj in ipairs(workspace:GetDescendants()) do
		if obj:IsA("BasePart") and obj ~= selectedPart then
			if isPartUnlocked(obj) and not obj.Anchored then
				table.insert(orbitingParts, obj)
				setNetworkOwnership(obj)
			end
		end
	end
	
	if #orbitingParts == 0 then
		warn("No unlocked unanchored parts found!")
		return
	end
	
	-- Sort parts by color if rainbow mode is on (keeps original colors, just arranges them!)
	if rainbowMode then
		table.sort(orbitingParts, function(a, b)
			local function colorToHue(color)
				local r, g, b = color.R, color.G, color.B
				local max = math.max(r, g, b)
				local min = math.min(r, g, b)
				local h = 0
				
				if max == min then
					h = 0
				elseif max == r then
					h = (60 * ((g - b) / (max - min)) + 360) % 360
				elseif max == g then
					h = (60 * ((b - r) / (max - min)) + 120) % 360
				else
					h = (60 * ((r - g) / (max - min)) + 240) % 360
				end
				
				return h
			end
			
			return colorToHue(a.Color) < colorToHue(b.Color)
		end)
		print("ðŸŒˆ Rainbow mode: Parts arranged by color spectrum (Redâ†’Orangeâ†’Yellowâ†’Greenâ†’Blueâ†’Purple)!")
	end
	
	print("ðŸŒŸ Orbiting " .. #orbitingParts .. " parts!")
	print("Shape: " .. orbitShape .. " | Animation: " .. animationMode)
	print("Rainbow Mode: " .. tostring(rainbowMode))
	
	local orbitData = {}
	
	for i, part in ipairs(orbitingParts) do
		local radius = orbitDistance
		local speed = orbitSpeed / orbitDistance
		local baseAngle
		
		if gapMode == "None" then
			baseAngle = (i / #orbitingParts) * math.pi * 2
		elseif gapMode == "GapPerPart" then
			radius = orbitDistance + ((i - 1) * gapValue)
			baseAngle = (i / #orbitingParts) * math.pi * 2
		elseif gapMode == "GapBetweenParts" then
			local arcLengthPerPart = gapValue
			local totalArcLength = arcLengthPerPart * #orbitingParts
			radius = totalArcLength / (2 * math.pi)
			baseAngle = (i / #orbitingParts) * math.pi * 2
		end
		
		orbitData[part] = {
			baseAngle = baseAngle,
			radius = radius,
			speed = speed,
			index = i,
			phaseOffset = math.random() * math.pi * 2
		}
	end
	
	local startTime = tick()
	orbitConnection = RunService.Heartbeat:Connect(function()
		if not selectedPart or not selectedPart.Parent then
			stopOrbiting()
			return
		end
		
		local centerPos = selectedPart.Position
		local time = tick() - startTime
		
		for part, data in pairs(orbitData) do
			if part and part.Parent then
				local currentAngle = data.baseAngle + (time * data.speed)
				local basePos = calculatePosition(
					centerPos,
					currentAngle,
					data.radius,
					0,
					time,
					data.index,
					#orbitingParts
				)
				
				local targetPos = applyAnimation(
					part,
					basePos,
					centerPos,
					time,
					data.index,
					#orbitingParts,
					data.phaseOffset
				)
				
				-- Rainbow mode doesn't change colors, just arranges them!
				
				local direction = (targetPos - part.Position)
				local distance = direction.Magnitude
				
				if distance > 0.1 then
					part.AssemblyLinearVelocity = direction.Unit * math.min(distance * 5, 50)
				else
					part.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
				end
				
				if animationMode ~= "Spin" and animationMode ~= "Flip" and animationMode ~= "Chaos" then
					part.AssemblyAngularVelocity = Vector3.new(
						math.sin(time) * 0.5,
						data.speed * 2,
						math.cos(time) * 0.5
					)
				end
			end
		end
	end)
	
	orbitButton.Text = "STOP ORBITING"
	orbitButton.BackgroundColor3 = Color3.fromRGB(120, 50, 50)
end

-- Button Events
selectionButton.MouseButton1Click:Connect(function()
	selectionMode = not selectionMode
	selectionButton.Text = selectionMode and "Selection Mode: ON" or "Enable Selection Mode"
	selectionButton.BackgroundColor3 = selectionMode and Color3.fromRGB(50, 100, 150) or Color3.fromRGB(60, 60, 60)
end)

hideSelectionToggle.MouseButton1Click:Connect(function()
	hideSelectionBox = not hideSelectionBox
	hideSelectionToggle.Text = hideSelectionBox and "Hide Selection Box: ON" or "Hide Selection Box: OFF"
	hideSelectionToggle.BackgroundColor3 = hideSelectionBox and Color3.fromRGB(50, 100, 150) or Color3.fromRGB(60, 60, 60)
	
	if hideSelectionBox and selectionBox then
		selectionBox:Destroy()
		selectionBox = nil
	elseif not hideSelectionBox and selectedPart then
		createSelectionBox(selectedPart)
	end
end)

rainbowToggle.MouseButton1Click:Connect(function()
	rainbowMode = not rainbowMode
	rainbowToggle.Text = rainbowMode and "ðŸŒˆ RAINBOW COLOR SORTING: ON" or "ðŸŒˆ RAINBOW COLOR SORTING: OFF"
	rainbowToggle.BackgroundColor3 = rainbowMode and Color3.fromRGB(100, 50, 150) or Color3.fromRGB(60, 60, 60)
end)

local function updateGapMode(mode)
	gapMode = mode
	gapModeLabel.Text = "Gap Mode: " .. mode
	for _, btn in ipairs({gapModeNone, gapModePerPart, gapModeBetween}) do
		btn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
	end
	if mode == "None" then gapModeNone.BackgroundColor3 = Color3.fromRGB(50, 100, 50)
	elseif mode == "GapPerPart" then gapModePerPart.BackgroundColor3 = Color3.fromRGB(50, 100, 50)
	else gapModeBetween.BackgroundColor3 = Color3.fromRGB(50, 100, 50) end
end

gapModeNone.MouseButton1Click:Connect(function() updateGapMode("None") end)
gapModePerPart.MouseButton1Click:Connect(function() updateGapMode("GapPerPart") end)
gapModeBetween.MouseButton1Click:Connect(function() updateGapMode("GapBetweenParts") end)

for _, data in ipairs(shapeButtons) do
	data.button.MouseButton1Click:Connect(function()
		orbitShape = data.shape
		shapeLabel.Text = "âœ¨ Shape: " .. orbitShape
		for _, btnData in ipairs(shapeButtons) do
			btnData.button.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
		end
		data.button.BackgroundColor3 = Color3.fromRGB(50, 100, 50)
	end)
end

for _, data in ipairs(animButtons) do
	data.button.MouseButton1Click:Connect(function()
		animationMode = data.anim
		animLabel.Text = "ðŸŽ­ Animation: " .. animationMode
		for _, btnData in ipairs(animButtons) do
			btnData.button.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
		end
		data.button.BackgroundColor3 = Color3.fromRGB(50, 100, 50)
	end)
end

wireframeToggle.MouseButton1Click:Connect(function()
	wireframeMode = not wireframeMode
	wireframeLabel.Text = wireframeMode and "Wireframe Mode: ON" or "Wireframe Mode: OFF"
	wireframeToggle.BackgroundColor3 = wireframeMode and Color3.fromRGB(100, 50, 150) or Color3.fromRGB(60, 60, 60)
end)

wingsToggle.MouseButton1Click:Connect(function()
	if wingsMode then destroyWings() else createWings() end
end)

hammerToggle.MouseButton1Click:Connect(function()
	if hammerMode then destroyHammer() else createHammer() end
end)

hammerSmash.MouseButton1Click:Connect(smashHammer)

UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed then return end
	if input.KeyCode == Enum.KeyCode.M and hammerMode then
		smashHammer()
	end
end)

orbitButton.MouseButton1Click:Connect(function()
	if orbitConnection then stopOrbiting() else startOrbiting() end
end)

mouse.Button1Down:Connect(function()
	if selectionMode then
		local target = mouse.Target
		if target and isPartUnlocked(target) then
			selectPart(target)
		end
	end
end)

player.CharacterAdded:Connect(function()
	stopOrbiting()
	clearSelection()
	destroyHammer()
	destroyWings()
end)

print("ðŸŒŸðŸŒŸðŸŒŸ MEGA ULTIMATE ORBIT SCRIPT LOADED! ðŸŒŸðŸŒŸðŸŒŸ")
print("âœ¨ 50 ORBIT SHAPES!")
print("ðŸŽ­ 26 ANIMATIONS!")
print("ðŸ‘¼ ULTRAKILL WINGS!")
print("ðŸŒˆ RAINBOW COLOR SORTING!")
print("ðŸ”¨ 3D HAMMER WITH GROUND SMASH!")
print("")
print("Your friends are gonna be SO IMPRESSED! uwu")
