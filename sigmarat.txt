-- Orbit Parts Script with GUI and Wireframe Mode - FIXED HAMMER
-- Place this in StarterPlayerScripts or StarterCharacterScripts

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local player = Players.LocalPlayer
local mouse = player:GetMouse()
local camera = workspace.CurrentCamera

-- Variables
local selectionMode = false
local selectedPart = nil
local orbitingParts = {}
local orbitConnection = nil
local selectionBox = nil
local hideSelectionBox = false

-- Settings Variables
local orbitDistance = 10
local orbitSpeed = 1
local gapMode = "None" -- "None", "GapPerPart", "GapBetweenParts"
local gapValue = 2
local orbitShape = "Circle" -- "Circle", "Sphere", "Cube", "Spiral", "Wave", "Helix", "Figure8", "Star", "Pentagon", "Hexagon", "Octagon", "Diamond", "Heart", "Infinity", "Flower", "DNA", "Tornado", "Galaxy", "Rings", "Mobius"
local animationMode = "None" -- "None", "Pulse", "Expand", "Wobble", "Spin", "Shake", "Bounce", "Twist", "Orbit", "Flip", "Stretch", "Swirl", "Jitter", "Wave"
local wireframeMode = false
local wireframeShape = "Cube" -- "Cube", "Pyramid", "Octahedron", "Tetrahedron", "Icosahedron", "Torus", "Cylinder", "Dodecahedron", "Sphere"
local hammerMode = false
local hammerStatue = nil
local hammerParts = {}
local hammerConnection = nil
local hammerDepth = 3 -- Depth of hammer (3 studs thick)

-- Create GUI
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "OrbitPartsGUI"
screenGui.ResetOnSpawn = false
screenGui.Parent = player:WaitForChild("PlayerGui")

-- Main Frame
local mainFrame = Instance.new("Frame")
mainFrame.Name = "MainFrame"
mainFrame.Size = UDim2.new(0, 350, 0, 500)
mainFrame.Position = UDim2.new(0.5, -175, 0.5, -250)
mainFrame.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
mainFrame.BorderSizePixel = 2
mainFrame.BorderColor3 = Color3.fromRGB(255, 255, 255)
mainFrame.Active = true
mainFrame.Draggable = true
mainFrame.Parent = screenGui

-- Scroll Frame for content
local scrollFrame = Instance.new("ScrollingFrame")
scrollFrame.Name = "ScrollFrame"
scrollFrame.Size = UDim2.new(1, 0, 1, -30)
scrollFrame.Position = UDim2.new(0, 0, 0, 30)
scrollFrame.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
scrollFrame.BorderSizePixel = 0
scrollFrame.ScrollBarThickness = 6
scrollFrame.CanvasSize = UDim2.new(0, 0, 0, 1850)
scrollFrame.Parent = mainFrame

-- Title
local title = Instance.new("TextLabel")
title.Name = "Title"
title.Size = UDim2.new(1, 0, 0, 30)
title.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
title.BorderSizePixel = 0
title.Text = "Orbit Parts Controller"
title.TextColor3 = Color3.fromRGB(255, 255, 255)
title.TextSize = 16
title.Font = Enum.Font.SourceSansBold
title.Parent = mainFrame

-- Helper function to create labeled textboxes
local function createLabeledTextbox(name, labelText, defaultValue, yPosition, parent)
	local label = Instance.new("TextLabel")
	label.Name = name .. "Label"
	label.Size = UDim2.new(0.9, 0, 0, 20)
	label.Position = UDim2.new(0.05, 0, 0, yPosition)
	label.BackgroundTransparency = 1
	label.Text = labelText
	label.TextColor3 = Color3.fromRGB(220, 220, 220)
	label.TextSize = 12
	label.Font = Enum.Font.SourceSans
	label.TextXAlignment = Enum.TextXAlignment.Left
	label.Parent = parent
	
	local textbox = Instance.new("TextBox")
	textbox.Name = name
	textbox.Size = UDim2.new(0.9, 0, 0, 30)
	textbox.Position = UDim2.new(0.05, 0, 0, yPosition + 22)
	textbox.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
	textbox.BorderSizePixel = 1
	textbox.BorderColor3 = Color3.fromRGB(100, 100, 100)
	textbox.Text = tostring(defaultValue)
	textbox.TextColor3 = Color3.fromRGB(255, 255, 255)
	textbox.TextSize = 14
	textbox.Font = Enum.Font.SourceSans
	textbox.ClearTextOnFocus = false
	textbox.Parent = parent
	
	return textbox
end

-- Selection Mode Button
local selectionButton = Instance.new("TextButton")
selectionButton.Name = "SelectionButton"
selectionButton.Size = UDim2.new(0.9, 0, 0, 40)
selectionButton.Position = UDim2.new(0.05, 0, 0, 5)
selectionButton.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
selectionButton.BorderSizePixel = 1
selectionButton.BorderColor3 = Color3.fromRGB(100, 100, 100)
selectionButton.Text = "Enable Selection Mode"
selectionButton.TextColor3 = Color3.fromRGB(255, 255, 255)
selectionButton.TextSize = 14
selectionButton.Font = Enum.Font.SourceSans
selectionButton.Parent = scrollFrame

-- Selected Part Label
local selectedLabel = Instance.new("TextLabel")
selectedLabel.Name = "SelectedLabel"
selectedLabel.Size = UDim2.new(0.9, 0, 0, 30)
selectedLabel.Position = UDim2.new(0.05, 0, 0, 50)
selectedLabel.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
selectedLabel.BorderSizePixel = 1
selectedLabel.BorderColor3 = Color3.fromRGB(100, 100, 100)
selectedLabel.Text = "Selected: None"
selectedLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
selectedLabel.TextSize = 12
selectedLabel.Font = Enum.Font.SourceSans
selectedLabel.Parent = scrollFrame

-- Hide Selection Box Toggle
local hideSelectionToggle = Instance.new("TextButton")
hideSelectionToggle.Name = "HideSelectionToggle"
hideSelectionToggle.Size = UDim2.new(0.9, 0, 0, 30)
hideSelectionToggle.Position = UDim2.new(0.05, 0, 0, 85)
hideSelectionToggle.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
hideSelectionToggle.BorderSizePixel = 1
hideSelectionToggle.BorderColor3 = Color3.fromRGB(100, 100, 100)
hideSelectionToggle.Text = "Hide Selection Box: OFF"
hideSelectionToggle.TextColor3 = Color3.fromRGB(255, 255, 255)
hideSelectionToggle.TextSize = 12
hideSelectionToggle.Font = Enum.Font.SourceSans
hideSelectionToggle.Parent = scrollFrame

-- Orbit Distance Input
local distanceTextbox = createLabeledTextbox("DistanceTextbox", "Orbit Distance (studs):", orbitDistance, 125, scrollFrame)

-- Orbit Speed Input
local speedTextbox = createLabeledTextbox("SpeedTextbox", "Orbit Speed (studs/second):", orbitSpeed, 190, scrollFrame)

-- Gap Mode Section Label
local gapModeLabel = Instance.new("TextLabel")
gapModeLabel.Name = "GapModeLabel"
gapModeLabel.Size = UDim2.new(0.9, 0, 0, 25)
gapModeLabel.Position = UDim2.new(0.05, 0, 0, 220)
gapModeLabel.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
gapModeLabel.BorderSizePixel = 1
gapModeLabel.BorderColor3 = Color3.fromRGB(100, 100, 100)
gapModeLabel.Text = "Gap Mode: None"
gapModeLabel.TextColor3 = Color3.fromRGB(255, 255, 100)
gapModeLabel.TextSize = 13
gapModeLabel.Font = Enum.Font.SourceSansBold
gapModeLabel.Parent = scrollFrame

-- Helper function to create small buttons
local function createSmallButton(name, text, position)
	local button = Instance.new("TextButton")
	button.Name = name
	button.Size = UDim2.new(0.28, 0, 0, 28)
	button.Position = position
	button.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
	button.BorderSizePixel = 1
	button.BorderColor3 = Color3.fromRGB(100, 100, 100)
	button.Text = text
	button.TextColor3 = Color3.fromRGB(255, 255, 255)
	button.TextSize = 11
	button.Font = Enum.Font.SourceSans
	button.Parent = scrollFrame
	return button
end

-- Gap Mode Buttons
local gapModeNone = createSmallButton("GapModeNone", "None", UDim2.new(0.05, 0, 0, 250))
gapModeNone.BackgroundColor3 = Color3.fromRGB(50, 100, 50)
local gapModePerPart = createSmallButton("GapModePerPart", "Gap/Part", UDim2.new(0.36, 0, 0, 250))
local gapModeBetween = createSmallButton("GapModeBetween", "Gap Between", UDim2.new(0.67, 0, 0, 250))

-- Gap Value Input
local gapTextbox = createLabeledTextbox("GapTextbox", "Gap Value (studs):", gapValue, 290, scrollFrame)

-- Orbit Shape Section
local shapeLabel = Instance.new("TextLabel")
shapeLabel.Name = "ShapeLabel"
shapeLabel.Size = UDim2.new(0.9, 0, 0, 25)
shapeLabel.Position = UDim2.new(0.05, 0, 0, 390)
shapeLabel.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
shapeLabel.BorderSizePixel = 1
shapeLabel.BorderColor3 = Color3.fromRGB(100, 100, 100)
shapeLabel.Text = "Orbit Shape: Circle"
shapeLabel.TextColor3 = Color3.fromRGB(100, 255, 255)
shapeLabel.TextSize = 13
shapeLabel.Font = Enum.Font.SourceSansBold
shapeLabel.Parent = scrollFrame

-- Shape Buttons
local shapeCircle = createSmallButton("ShapeCircle", "Circle", UDim2.new(0.05, 0, 0, 420))
shapeCircle.BackgroundColor3 = Color3.fromRGB(50, 100, 50)
local shapeSphere = createSmallButton("ShapeSphere", "Sphere", UDim2.new(0.36, 0, 0, 420))
local shapeCube = createSmallButton("ShapeCube", "Cube", UDim2.new(0.67, 0, 0, 420))
local shapeSpiral = createSmallButton("ShapeSpiral", "Spiral", UDim2.new(0.05, 0, 0, 453))
local shapeWave = createSmallButton("ShapeWave", "Wave", UDim2.new(0.36, 0, 0, 453))
local shapeHelix = createSmallButton("ShapeHelix", "Helix", UDim2.new(0.67, 0, 0, 453))
local shapeFigure8 = createSmallButton("ShapeFigure8", "Figure 8", UDim2.new(0.05, 0, 0, 486))
local shapeStar = createSmallButton("ShapeStar", "Star", UDim2.new(0.36, 0, 0, 486))
local shapePentagon = createSmallButton("ShapePentagon", "Pentagon", UDim2.new(0.67, 0, 0, 486))
local shapeHexagon = createSmallButton("ShapeHexagon", "Hexagon", UDim2.new(0.05, 0, 0, 519))
local shapeOctagon = createSmallButton("ShapeOctagon", "Octagon", UDim2.new(0.36, 0, 0, 519))
local shapeDiamond = createSmallButton("ShapeDiamond", "Diamond", UDim2.new(0.67, 0, 0, 519))
local shapeHeart = createSmallButton("ShapeHeart", "Heart", UDim2.new(0.05, 0, 0, 552))
local shapeInfinity = createSmallButton("ShapeInfinity", "Infinity", UDim2.new(0.36, 0, 0, 552))
local shapeFlower = createSmallButton("ShapeFlower", "Flower", UDim2.new(0.67, 0, 0, 552))
local shapeDNA = createSmallButton("ShapeDNA", "DNA", UDim2.new(0.05, 0, 0, 585))
local shapeTornado = createSmallButton("ShapeTornado", "Tornado", UDim2.new(0.36, 0, 0, 585))
local shapeGalaxy = createSmallButton("ShapeGalaxy", "Galaxy", UDim2.new(0.67, 0, 0, 585))
local shapeRings = createSmallButton("ShapeRings", "Rings", UDim2.new(0.05, 0, 0, 618))
local shapeMobius = createSmallButton("ShapeMobius", "Mobius", UDim2.new(0.36, 0, 0, 618))

-- Animation Mode Section
local animLabel = Instance.new("TextLabel")
animLabel.Name = "AnimLabel"
animLabel.Size = UDim2.new(0.9, 0, 0, 25)
animLabel.Position = UDim2.new(0.05, 0, 0, 662)
animLabel.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
animLabel.BorderSizePixel = 1
animLabel.BorderColor3 = Color3.fromRGB(100, 100, 100)
animLabel.Text = "Animation: None"
animLabel.TextColor3 = Color3.fromRGB(255, 150, 255)
animLabel.TextSize = 13
animLabel.Font = Enum.Font.SourceSansBold
animLabel.Parent = scrollFrame

-- Animation Buttons
local animNone = createSmallButton("AnimNone", "None", UDim2.new(0.05, 0, 0, 692))
animNone.BackgroundColor3 = Color3.fromRGB(50, 100, 50)
local animPulse = createSmallButton("AnimPulse", "Pulse", UDim2.new(0.36, 0, 0, 692))
local animExpand = createSmallButton("AnimExpand", "Expand", UDim2.new(0.67, 0, 0, 692))
local animWobble = createSmallButton("AnimWobble", "Wobble", UDim2.new(0.05, 0, 0, 725))
local animSpin = createSmallButton("AnimSpin", "Spin", UDim2.new(0.36, 0, 0, 725))
local animShake = createSmallButton("AnimShake", "Shake", UDim2.new(0.67, 0, 0, 725))
local animBounce = createSmallButton("AnimBounce", "Bounce", UDim2.new(0.05, 0, 0, 758))
local animTwist = createSmallButton("AnimTwist", "Twist", UDim2.new(0.36, 0, 0, 758))
local animOrbit = createSmallButton("AnimOrbit", "Orbit", UDim2.new(0.67, 0, 0, 758))
local animFlip = createSmallButton("AnimFlip", "Flip", UDim2.new(0.05, 0, 0, 791))
local animStretch = createSmallButton("AnimStretch", "Stretch", UDim2.new(0.36, 0, 0, 791))
local animSwirl = createSmallButton("AnimSwirl", "Swirl", UDim2.new(0.67, 0, 0, 791))
local animJitter = createSmallButton("AnimJitter", "Jitter", UDim2.new(0.05, 0, 0, 824))
local animWaveAnim = createSmallButton("AnimWaveAnim", "Wave", UDim2.new(0.36, 0, 0, 824))

-- Wireframe Section
local wireframeLabel = Instance.new("TextLabel")
wireframeLabel.Name = "WireframeLabel"
wireframeLabel.Size = UDim2.new(0.9, 0, 0, 25)
wireframeLabel.Position = UDim2.new(0.05, 0, 0, 868)
wireframeLabel.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
wireframeLabel.BorderSizePixel = 1
wireframeLabel.BorderColor3 = Color3.fromRGB(100, 100, 100)
wireframeLabel.Text = "Wireframe Mode: OFF"
wireframeLabel.TextColor3 = Color3.fromRGB(255, 100, 255)
wireframeLabel.TextSize = 13
wireframeLabel.Font = Enum.Font.SourceSansBold
wireframeLabel.Parent = scrollFrame

-- Wireframe Toggle
local wireframeToggle = Instance.new("TextButton")
wireframeToggle.Name = "WireframeToggle"
wireframeToggle.Size = UDim2.new(0.9, 0, 0, 35)
wireframeToggle.Position = UDim2.new(0.05, 0, 0, 898)
wireframeToggle.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
wireframeToggle.BorderSizePixel = 1
wireframeToggle.BorderColor3 = Color3.fromRGB(100, 100, 100)
wireframeToggle.Text = "Toggle Wireframe 3D Shapes"
wireframeToggle.TextColor3 = Color3.fromRGB(255, 255, 255)
wireframeToggle.TextSize = 13
wireframeToggle.Font = Enum.Font.SourceSansBold
wireframeToggle.Parent = scrollFrame

-- Wireframe Shape Buttons
local wireframeCube = createSmallButton("WireframeCube", "Cube", UDim2.new(0.05, 0, 0, 943))
wireframeCube.BackgroundColor3 = Color3.fromRGB(50, 100, 50)
local wireframePyramid = createSmallButton("WireframePyramid", "Pyramid", UDim2.new(0.36, 0, 0, 943))
local wireframeOcta = createSmallButton("WireframeOcta", "Octahedron", UDim2.new(0.67, 0, 0, 943))
wireframeOcta.TextSize = 10
local wireframeTetra = createSmallButton("WireframeTetra", "Tetrahedron", UDim2.new(0.05, 0, 0, 976))
wireframeTetra.TextSize = 10
local wireframeIco = createSmallButton("WireframeIco", "Icosahedron", UDim2.new(0.36, 0, 0, 976))
wireframeIco.TextSize = 10
local wireframeTorus = createSmallButton("WireframeTorus", "Torus", UDim2.new(0.67, 0, 0, 976))
local wireframeCylinder = createSmallButton("WireframeCylinder", "Cylinder", UDim2.new(0.05, 0, 0, 1009))
wireframeCylinder.TextSize = 11
local wireframeDodeca = createSmallButton("WireframeDodeca", "Dodecahedron", UDim2.new(0.36, 0, 0, 1009))
wireframeDodeca.TextSize = 9
local wireframeSphere = createSmallButton("WireframeSphere", "Sphere", UDim2.new(0.67, 0, 0, 1009))

-- Hammer Mode Section
local hammerLabel = Instance.new("TextLabel")
hammerLabel.Name = "HammerLabel"
hammerLabel.Size = UDim2.new(0.9, 0, 0, 25)
hammerLabel.Position = UDim2.new(0.05, 0, 0, 1053)
hammerLabel.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
hammerLabel.BorderSizePixel = 1
hammerLabel.BorderColor3 = Color3.fromRGB(100, 100, 100)
hammerLabel.Text = "Hammer Mode: OFF"
hammerLabel.TextColor3 = Color3.fromRGB(255, 200, 50)
hammerLabel.TextSize = 13
hammerLabel.Font = Enum.Font.SourceSansBold
hammerLabel.Parent = scrollFrame

-- Hammer Toggle Button
local hammerToggle = Instance.new("TextButton")
hammerToggle.Name = "HammerToggle"
hammerToggle.Size = UDim2.new(0.9, 0, 0, 40)
hammerToggle.Position = UDim2.new(0.05, 0, 0, 1083)
hammerToggle.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
hammerToggle.BorderSizePixel = 1
hammerToggle.BorderColor3 = Color3.fromRGB(100, 100, 100)
hammerToggle.Text = "Create 3D Hammer (16x16x3 studs)"
hammerToggle.TextColor3 = Color3.fromRGB(255, 255, 255)
hammerToggle.TextSize = 13
hammerToggle.Font = Enum.Font.SourceSansBold
hammerToggle.Parent = scrollFrame

-- Hammer Smash Button
local hammerSmash = Instance.new("TextButton")
hammerSmash.Name = "HammerSmash"
hammerSmash.Size = UDim2.new(0.9, 0, 0, 40)
hammerSmash.Position = UDim2.new(0.05, 0, 0, 1133)
hammerSmash.BackgroundColor3 = Color3.fromRGB(100, 40, 40)
hammerSmash.BorderSizePixel = 1
hammerSmash.BorderColor3 = Color3.fromRGB(100, 100, 100)
hammerSmash.Text = "SMASH GROUND (Press M)"
hammerSmash.TextColor3 = Color3.fromRGB(255, 255, 255)
hammerSmash.TextSize = 14
hammerSmash.Font = Enum.Font.SourceSansBold
hammerSmash.Parent = scrollFrame

-- Orbit Button
local orbitButton = Instance.new("TextButton")
orbitButton.Name = "OrbitButton"
orbitButton.Size = UDim2.new(0.9, 0, 0, 45)
orbitButton.Position = UDim2.new(0.05, 0, 0, 1188)
orbitButton.BackgroundColor3 = Color3.fromRGB(50, 120, 50)
orbitButton.BorderSizePixel = 1
orbitButton.BorderColor3 = Color3.fromRGB(100, 100, 100)
orbitButton.Text = "All Unlocked Unanchored Parts Orbit"
orbitButton.TextColor3 = Color3.fromRGB(255, 255, 255)
orbitButton.TextSize = 13
orbitButton.Font = Enum.Font.SourceSansBold
orbitButton.Parent = scrollFrame

-- Info Label
local infoLabel = Instance.new("TextLabel")
infoLabel.Name = "InfoLabel"
infoLabel.Size = UDim2.new(0.9, 0, 0, 310)
infoLabel.Position = UDim2.new(0.05, 0, 0, 1248)
infoLabel.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
infoLabel.BorderSizePixel = 1
infoLabel.BorderColor3 = Color3.fromRGB(80, 80, 100)
infoLabel.Text = "ðŸ”· 20 ORBIT SHAPES: Circle, Sphere, Cube, Spiral, Wave, Helix, Figure 8, Star, Pentagon, Hexagon, Octagon, Diamond, Heart, Infinity, Flower, DNA, Tornado, Galaxy, Rings, Mobius\n\nâœ¨ Perfect Polygon Formation: Parts auto-arrange into perfect geometric shapes!\n\nðŸŽ­ 14 ANIMATIONS: Pulse, Expand, Wobble, Spin, Shake, Bounce, Twist, Orbit, Flip, Stretch, Swirl, Jitter, Wave\n\nðŸ”² 9 WIREFRAME 3D SHAPES: Cube, Pyramid, Octahedron, Tetrahedron, Icosahedron, Torus, Cylinder, Dodecahedron, Sphere\n\nðŸ”¨ 3D Hammer Mode:\nâ€¢ Hammer follows block rotation (X/Z axis)\nâ€¢ 16x16x3 studs with depth\nâ€¢ Positioned 4 studs beside block\nâ€¢ SMASHES ground on impact!\nâ€¢ Unused parts EXPLODE at impact zone!"
infoLabel.TextColor3 = Color3.fromRGB(180, 180, 200)
infoLabel.TextSize = 10
infoLabel.Font = Enum.Font.SourceSans
infoLabel.TextWrapped = true
infoLabel.TextYAlignment = Enum.TextYAlignment.Top
infoLabel.Parent = scrollFrame

-- Functions
local function isPartUnlocked(part)
	if not part:IsA("BasePart") then return false end
	if part.Locked then return false end
	return true
end

local function canSetNetworkOwnership(part)
	local success = pcall(function()
		part:GetNetworkOwner()
	end)
	return success
end

local function setNetworkOwnership(part)
	if canSetNetworkOwnership(part) then
		pcall(function()
			part:SetNetworkOwner(player)
		end)
	end
end

local function createSelectionBox(part)
	if selectionBox then
		selectionBox:Destroy()
	end
	
	if not hideSelectionBox then
		selectionBox = Instance.new("SelectionBox")
		selectionBox.Adornee = part
		selectionBox.Color3 = Color3.fromRGB(0, 255, 0)
		selectionBox.LineThickness = 0.05
		selectionBox.SurfaceTransparency = 0.7
		selectionBox.Parent = workspace
	end
end

local function clearSelection()
	if selectionBox then
		selectionBox:Destroy()
		selectionBox = nil
	end
	selectedPart = nil
	selectedLabel.Text = "Selected: None"
end

local function selectPart(part)
	if not isPartUnlocked(part) then
		warn("Cannot select locked part!")
		return
	end
	
	selectedPart = part
	createSelectionBox(part)
	selectedLabel.Text = "Selected: " .. part.Name
	selectionMode = false
	selectionButton.Text = "Enable Selection Mode"
	selectionButton.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
end

local function stopOrbiting()
	if orbitConnection then
		orbitConnection:Disconnect()
		orbitConnection = nil
	end
	
	-- Clear network ownership from orbiting parts
	for _, part in ipairs(orbitingParts) do
		if part and part.Parent then
			pcall(function()
				part:SetNetworkOwnershipAuto()
			end)
		end
	end
	
	orbitingParts = {}
	orbitButton.Text = "All Unlocked Unanchored Parts Orbit"
	orbitButton.BackgroundColor3 = Color3.fromRGB(50, 120, 50)
end

local function destroyHammer()
	if hammerConnection then
		hammerConnection:Disconnect()
		hammerConnection = nil
	end
	
	-- Return all hammer parts to normal
	for _, part in ipairs(hammerParts) do
		if part and part.Parent then
			pcall(function()
				part:SetNetworkOwnershipAuto()
			end)
		end
	end
	
	hammerParts = {}
	hammerMode = false
	hammerLabel.Text = "Hammer Mode: OFF"
	hammerToggle.Text = "Create Hammer (16x16 studs)"
	hammerToggle.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
end

local function createHammer()
	if not selectedPart or not selectedPart.Parent then
		warn("No valid part selected!")
		return
	end
	
	destroyHammer()
	
	-- Collect all unlocked unanchored parts
	local allParts = {}
	for _, obj in ipairs(workspace:GetDescendants()) do
		if obj:IsA("BasePart") and obj ~= selectedPart then
			if isPartUnlocked(obj) and not obj.Anchored then
				table.insert(allParts, obj)
				setNetworkOwnership(obj)
			end
		end
	end
	
	if #allParts < 20 then
		warn("Not enough parts to create 3D hammer! Need at least 20 unlocked unanchored parts.")
		return
	end
	
	-- Define 3D hammer shape positions (16 height x 16 width x 3 depth)
	-- Handle: 2 studs wide, 12 studs tall, 3 studs deep
	-- Head: 10 studs wide, 4 studs tall, 3 studs deep
	local hammerPositions = {}
	
	-- Create handle (2x12x3 vertical column)
	for y = 0, 11 do
		for x = -0.5, 0.5, 1 do
			for z = -1, 1, 1 do
				table.insert(hammerPositions, Vector3.new(x, y, z))
			end
		end
	end
	
	-- Create hammer head (10x4x3 solid block at top)
	for y = 12, 15 do
		for x = -5, 4, 1 do
			for z = -1, 1, 1 do
				-- Make front/back and sides visible, with some interior structure
				if z == -1 or z == 1 or x == -5 or x == 4 or y == 12 or y == 15 then
					table.insert(hammerPositions, Vector3.new(x, y, z))
				elseif (y == 13 or y == 14) and (x == -2 or x == 1) and z == 0 then
					-- Interior support beams
					table.insert(hammerPositions, Vector3.new(x, y, z))
				end
			end
		end
	end
	
	-- Assign parts to positions
	for i = 1, math.min(#hammerPositions, #allParts) do
		hammerParts[i] = allParts[i]
	end
	
	print("3D Hammer created with " .. #hammerParts .. " parts")
	print("Unused parts: " .. (#allParts - #hammerParts) .. " will explode at ground impact!")
	
	hammerMode = true
	hammerLabel.Text = "Hammer Mode: ON (" .. #hammerParts .. " parts)"
	hammerToggle.Text = "Destroy Hammer"
	hammerToggle.BackgroundColor3 = Color3.fromRGB(120, 50, 50)
	
	-- Store unused parts for explosion
	local unusedParts = {}
	for i = #hammerParts + 1, #allParts do
		table.insert(unusedParts, allParts[i])
	end
	hammerStatue = {unusedParts = unusedParts, positions = hammerPositions}
	
	-- Animation loop - maintain hammer shape with smooth transitions
	local startTime = tick()
	hammerConnection = RunService.Heartbeat:Connect(function()
		if not selectedPart or not selectedPart.Parent then
			destroyHammer()
			return
		end
		
		local time = tick() - startTime
		local floatHeight = math.sin(time * 1.5) * 1.5
		local rotationAngle = math.sin(time * 0.8) * 0.15
		
		-- Get block rotation for hammer orientation (X and Z axis)
		local blockCFrame = selectedPart.CFrame
		local blockRotation = blockCFrame - blockCFrame.Position
		
		-- Position hammer 4 studs beside the block using the block's right vector
		local basePos = selectedPart.Position + blockCFrame.RightVector * 4 + Vector3.new(0, 8, 0)
		
		-- Update each hammer part to its designated position with rotation
		for i, part in ipairs(hammerParts) do
			if part and part.Parent and hammerPositions[i] then
				local offset = hammerPositions[i]
				
				-- Apply idle rotation
				local rotatedX = offset.X * math.cos(rotationAngle) - offset.Z * math.sin(rotationAngle)
				local rotatedZ = offset.X * math.sin(rotationAngle) + offset.Z * math.cos(rotationAngle)
				local rotatedOffset = Vector3.new(rotatedX, offset.Y + floatHeight, rotatedZ)
				
				-- Apply block rotation to offset
				local worldOffset = blockRotation * rotatedOffset
				local targetPos = basePos + worldOffset
				
				-- Smooth movement with velocity
				local direction = (targetPos - part.Position)
				local distance = direction.Magnitude
				
				if distance > 0.1 then
					part.AssemblyLinearVelocity = direction.Unit * math.min(distance * 10, 50)
				else
					part.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
				end
				
				-- Keep parts stable (no spinning)
				part.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
			end
		end
		
		-- Keep unused parts floating nearby around the hammer
		for i, part in ipairs(unusedParts) do
			if part and part.Parent then
				local angle = (i / #unusedParts) * math.pi * 2 + time * 0.5
				local radius = 12
				local orbitOffset = Vector3.new(
					math.cos(angle) * radius,
					math.sin(time * 2 + i) * 3,
					math.sin(angle) * radius
				)
				local unusedPos = basePos + blockRotation * orbitOffset
				
				local direction = (unusedPos - part.Position)
				local distance = direction.Magnitude
				
				if distance > 0.5 then
					part.AssemblyLinearVelocity = direction.Unit * math.min(distance * 5, 30)
				else
					part.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
				end
				
				part.AssemblyAngularVelocity = Vector3.new(
					math.sin(time + i) * 2,
					math.cos(time + i) * 2,
					0
				)
			end
		end
	end)
end

local function smashHammer()
	if not hammerMode or #hammerParts == 0 then
		warn("Hammer not created!")
		return
	end
	
	if not selectedPart or not selectedPart.Parent then
		warn("Selected part no longer exists!")
		return
	end
	
	print("ðŸ”¨ HAMMER SMASH! ðŸ’¥")
	
	-- Stop idle animation
	if hammerConnection then
		hammerConnection:Disconnect()
		hammerConnection = nil
	end
	
	local smashStartTime = tick()
	local smashDuration = 2.0
	local hammerPositions = hammerStatue.positions
	local unusedParts = hammerStatue.unusedParts
	local hasExploded = false
	
	-- Get block rotation
	local blockCFrame = selectedPart.CFrame
	local blockRotation = blockCFrame - blockCFrame.Position
	local basePos = selectedPart.Position + blockCFrame.RightVector * 4 + Vector3.new(0, 8, 0)
	
	-- Find ground position (impact point)
	local groundPos = selectedPart.Position + Vector3.new(0, -2, 0)
	
	hammerConnection = RunService.Heartbeat:Connect(function()
		if not selectedPart or not selectedPart.Parent then
			destroyHammer()
			return
		end
		
		-- Update rotation in case block rotates during smash
		blockCFrame = selectedPart.CFrame
		blockRotation = blockCFrame - blockCFrame.Position
		basePos = selectedPart.Position + blockCFrame.RightVector * 4 + Vector3.new(0, 8, 0)
		groundPos = selectedPart.Position + Vector3.new(0, -2, 0)
		
		local elapsed = tick() - smashStartTime
		local progress = math.min(elapsed / smashDuration, 1)
		
		if progress < 0.25 then
			-- Phase 1: Lift hammer up high
			local liftProgress = progress / 0.25
			local liftHeight = liftProgress * 25
			
			for i, part in ipairs(hammerParts) do
				if part and part.Parent and hammerPositions[i] then
					local offset = hammerPositions[i]
					local worldOffset = blockRotation * Vector3.new(offset.X, offset.Y + liftHeight, offset.Z)
					local partTargetPos = basePos + worldOffset
					
					local direction = (partTargetPos - part.Position)
					part.AssemblyLinearVelocity = direction * 15
					part.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
				end
			end
			
			-- Keep unused parts orbiting during windup
			for i, part in ipairs(unusedParts) do
				if part and part.Parent then
					local angle = (i / #unusedParts) * math.pi * 2 + elapsed * 2
					local radius = 12
					local orbitOffset = Vector3.new(
						math.cos(angle) * radius,
						math.sin(elapsed * 3 + i) * 4,
						math.sin(angle) * radius
					)
					local unusedPos = basePos + blockRotation * orbitOffset
					
					local direction = (unusedPos - part.Position)
					part.AssemblyLinearVelocity = direction * 8
					part.AssemblyAngularVelocity = Vector3.new(
						math.sin(elapsed + i) * 4,
						math.cos(elapsed + i) * 4,
						0
					)
				end
			end
			
		elseif progress < 0.65 then
			-- Phase 2: SMASH DOWN TO GROUND!
			local smashProgress = (progress - 0.25) / 0.4
			local currentHeight = 25 - (smashProgress * 35) -- Go from +25 to -10 (below ground)
			
			for i, part in ipairs(hammerParts) do
				if part and part.Parent and hammerPositions[i] then
					local offset = hammerPositions[i]
					local worldOffset = blockRotation * Vector3.new(offset.X, offset.Y + currentHeight, offset.Z)
					local partTargetPos = basePos + worldOffset
					
					local direction = (partTargetPos - part.Position)
					part.AssemblyLinearVelocity = direction * 30
					part.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
				end
			end
			
			-- Pull unused parts toward impact zone
			if smashProgress > 0.3 then
				for i, part in ipairs(unusedParts) do
					if part and part.Parent then
						local direction = (groundPos - part.Position)
						part.AssemblyLinearVelocity = direction.Unit * 40
					end
				end
			end
			
			-- EXPLODE UNUSED PARTS at impact moment (when hammer hits ground)
			if smashProgress > 0.8 and not hasExploded then
				hasExploded = true
				print("ðŸ’¥ GROUND IMPACT EXPLOSION! " .. #unusedParts .. " parts exploding from impact zone!")
				
				for _, part in ipairs(unusedParts) do
					if part and part.Parent then
						-- Calculate direction from ground impact point
						local directionFromImpact = (part.Position - groundPos).Unit
						local distance = (part.Position - groundPos).Magnitude
						local explosionForce = math.max(15, 1 - (distance / 100)) * 200
						
						-- Launch parts outward from ground impact with massive force
						part.AssemblyLinearVelocity = directionFromImpact * explosionForce + Vector3.new(
							math.random(-40, 40),
							math.random(80, 150), -- High upward force
							math.random(-40, 40)
						)
						
						-- Crazy spinning
						part.AssemblyAngularVelocity = Vector3.new(
							math.random(-25, 25),
							math.random(-25, 25),
							math.random(-25, 25)
						)
					end
				end
			end
			
		else
			-- Phase 3: Return to idle position
			if hammerConnection then
				hammerConnection:Disconnect()
				hammerConnection = nil
			end
			
			-- Restart idle animation
			local idleStartTime = tick()
			
			hammerConnection = RunService.Heartbeat:Connect(function()
				if not selectedPart or not selectedPart.Parent then
					destroyHammer()
					return
				end
				
				local time = tick() - idleStartTime
				local floatHeight = math.sin(time * 1.5) * 1.5
				local rotationAngle = math.sin(time * 0.8) * 0.15
				
				-- Update rotation
				blockCFrame = selectedPart.CFrame
				blockRotation = blockCFrame - blockCFrame.Position
				basePos = selectedPart.Position + blockCFrame.RightVector * 4 + Vector3.new(0, 8, 0)
				
				for i, part in ipairs(hammerParts) do
					if part and part.Parent and hammerPositions[i] then
						local offset = hammerPositions[i]
						
						-- Apply idle rotation
						local rotatedX = offset.X * math.cos(rotationAngle) - offset.Z * math.sin(rotationAngle)
						local rotatedZ = offset.X * math.sin(rotationAngle) + offset.Z * math.cos(rotationAngle)
						local rotatedOffset = Vector3.new(rotatedX, offset.Y + floatHeight, rotatedZ)
						
						-- Apply block rotation
						local worldOffset = blockRotation * rotatedOffset
						local partTargetPos = basePos + worldOffset
						
						local direction = (partTargetPos - part.Position)
						local distance = direction.Magnitude
						
						if distance > 0.1 then
							part.AssemblyLinearVelocity = direction.Unit * math.min(distance * 10, 50)
						else
							part.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
						end
						
						part.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
					end
				end
				
				-- Return unused parts to orbit
				for i, part in ipairs(unusedParts) do
					if part and part.Parent then
						local angle = (i / #unusedParts) * math.pi * 2 + time * 0.5
						local radius = 12
						local orbitOffset = Vector3.new(
							math.cos(angle) * radius,
							math.sin(time * 2 + i) * 3,
							math.sin(angle) * radius
						)
						local unusedPos = basePos + blockRotation * orbitOffset
						
						local direction = (unusedPos - part.Position)
						local distance = direction.Magnitude
						
						if distance > 1 then
							part.AssemblyLinearVelocity = direction.Unit * math.min(distance * 3, 25)
						else
							part.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
						end
						
						part.AssemblyAngularVelocity = Vector3.new(
							math.sin(time + i) * 2,
							math.cos(time + i) * 2,
							0
						)
					end
				end
			end)
			
			print("âœ… Hammer returned to idle position")
		end
	end)
end

-- Wireframe shape definitions (vertices and edges)
local wireframeShapes = {
	Cube = {
		vertices = {
			Vector3.new(-1, -1, -1), Vector3.new(1, -1, -1), Vector3.new(1, 1, -1), Vector3.new(-1, 1, -1),
			Vector3.new(-1, -1, 1), Vector3.new(1, -1, 1), Vector3.new(1, 1, 1), Vector3.new(-1, 1, 1)
		},
		edges = {
			{1,2},{2,3},{3,4},{4,1}, -- Back face
			{5,6},{6,7},{7,8},{8,5}, -- Front face
			{1,5},{2,6},{3,7},{4,8}  -- Connecting edges
		}
	},
	Pyramid = {
		vertices = {
			Vector3.new(-1, 0, -1), Vector3.new(1, 0, -1), Vector3.new(1, 0, 1), Vector3.new(-1, 0, 1),
			Vector3.new(0, 1.5, 0) -- Apex
		},
		edges = {
			{1,2},{2,3},{3,4},{4,1}, -- Base
			{1,5},{2,5},{3,5},{4,5}  -- Sides to apex
		}
	},
	Octahedron = {
		vertices = {
			Vector3.new(0, 1.4, 0), Vector3.new(0, -1.4, 0),
			Vector3.new(1, 0, 0), Vector3.new(-1, 0, 0),
			Vector3.new(0, 0, 1), Vector3.new(0, 0, -1)
		},
		edges = {
			{1,3},{1,4},{1,5},{1,6}, -- Top
			{2,3},{2,4},{2,5},{2,6}, -- Bottom
			{3,5},{5,4},{4,6},{6,3}  -- Middle
		}
	},
	Tetrahedron = {
		vertices = {
			Vector3.new(1, 1, 1), Vector3.new(-1, -1, 1),
			Vector3.new(-1, 1, -1), Vector3.new(1, -1, -1)
		},
		edges = {
			{1,2},{1,3},{1,4},{2,3},{2,4},{3,4}
		}
	},
	Icosahedron = {
		vertices = {
			Vector3.new(0, 1, 1.618), Vector3.new(0, 1, -1.618), Vector3.new(0, -1, 1.618), Vector3.new(0, -1, -1.618),
			Vector3.new(1, 1.618, 0), Vector3.new(1, -1.618, 0), Vector3.new(-1, 1.618, 0), Vector3.new(-1, -1.618, 0),
			Vector3.new(1.618, 0, 1), Vector3.new(1.618, 0, -1), Vector3.new(-1.618, 0, 1), Vector3.new(-1.618, 0, -1)
		},
		edges = {
			{1,5},{1,7},{1,9},{1,11},{1,3}, {2,5},{2,7},{2,10},{2,12},{2,4},
			{3,6},{3,8},{3,9},{3,11}, {4,6},{4,8},{4,10},{4,12},
			{5,9},{5,10},{5,7}, {6,9},{6,10},{6,8},
			{7,11},{7,12}, {8,11},{8,12}
		}
	},
	Torus = {
		vertices = (function()
			local verts = {}
			local majorRadius = 1.2
			local minorRadius = 0.4
			local majorSegs = 16
			local minorSegs = 8
			for i = 0, majorSegs - 1 do
				local theta = (i / majorSegs) * math.pi * 2
				for j = 0, minorSegs - 1 do
					local phi = (j / minorSegs) * math.pi * 2
					local x = (majorRadius + minorRadius * math.cos(phi)) * math.cos(theta)
					local y = minorRadius * math.sin(phi)
					local z = (majorRadius + minorRadius * math.cos(phi)) * math.sin(theta)
					table.insert(verts, Vector3.new(x, y, z))
				end
			end
			return verts
		end)(),
		edges = (function()
			local edges = {}
			local majorSegs = 16
			local minorSegs = 8
			for i = 0, majorSegs - 1 do
				for j = 0, minorSegs - 1 do
					local curr = i * minorSegs + j + 1
					local nextMinor = i * minorSegs + ((j + 1) % minorSegs) + 1
					local nextMajor = ((i + 1) % majorSegs) * minorSegs + j + 1
					table.insert(edges, {curr, nextMinor})
					table.insert(edges, {curr, nextMajor})
				end
			end
			return edges
		end)()
	},
	Cylinder = {
		vertices = (function()
			local verts = {}
			local radius = 1
			local height = 2
			local segments = 12
			-- Bottom circle
			for i = 0, segments - 1 do
				local angle = (i / segments) * math.pi * 2
				table.insert(verts, Vector3.new(math.cos(angle) * radius, -height/2, math.sin(angle) * radius))
			end
			-- Top circle
			for i = 0, segments - 1 do
				local angle = (i / segments) * math.pi * 2
				table.insert(verts, Vector3.new(math.cos(angle) * radius, height/2, math.sin(angle) * radius))
			end
			return verts
		end)(),
		edges = (function()
			local edges = {}
			local segments = 12
			-- Bottom circle edges
			for i = 1, segments do
				table.insert(edges, {i, (i % segments) + 1})
			end
			-- Top circle edges
			for i = 1, segments do
				table.insert(edges, {i + segments, ((i % segments) + 1) + segments})
			end
			-- Vertical edges connecting top and bottom
			for i = 1, segments do
				table.insert(edges, {i, i + segments})
			end
			return edges
		end)()
	},
	Dodecahedron = {
		vertices = (function()
			local phi = (1 + math.sqrt(5)) / 2
			return {
				Vector3.new(1, 1, 1), Vector3.new(1, 1, -1), Vector3.new(1, -1, 1), Vector3.new(1, -1, -1),
				Vector3.new(-1, 1, 1), Vector3.new(-1, 1, -1), Vector3.new(-1, -1, 1), Vector3.new(-1, -1, -1),
				Vector3.new(0, phi, 1/phi), Vector3.new(0, phi, -1/phi), Vector3.new(0, -phi, 1/phi), Vector3.new(0, -phi, -1/phi),
				Vector3.new(1/phi, 0, phi), Vector3.new(1/phi, 0, -phi), Vector3.new(-1/phi, 0, phi), Vector3.new(-1/phi, 0, -phi),
				Vector3.new(phi, 1/phi, 0), Vector3.new(phi, -1/phi, 0), Vector3.new(-phi, 1/phi, 0), Vector3.new(-phi, -1/phi, 0)
			}
		end)(),
		edges = {
			{1,9},{1,13},{1,17},{2,10},{2,14},{2,17},{3,11},{3,13},{3,18},{4,12},{4,14},{4,18},
			{5,9},{5,15},{5,19},{6,10},{6,16},{6,19},{7,11},{7,15},{7,20},{8,12},{8,16},{8,20},
			{9,10},{11,12},{13,15},{14,16},{17,18},{19,20}
		}
	},
	Sphere = {
		vertices = (function()
			local verts = {}
			local segments = 12
			local rings = 6
			for ring = 0, rings do
				local phi = (ring / rings) * math.pi
				for seg = 0, segments - 1 do
					local theta = (seg / segments) * math.pi * 2
					local x = math.sin(phi) * math.cos(theta) * 1.2
					local y = math.cos(phi) * 1.2
					local z = math.sin(phi) * math.sin(theta) * 1.2
					table.insert(verts, Vector3.new(x, y, z))
				end
			end
			return verts
		end)(),
		edges = (function()
			local edges = {}
			local segments = 12
			local rings = 6
			for ring = 0, rings - 1 do
				for seg = 0, segments - 1 do
					local curr = ring * segments + seg + 1
					local nextSeg = ring * segments + ((seg + 1) % segments) + 1
					local nextRing = (ring + 1) * segments + seg + 1
					table.insert(edges, {curr, nextSeg})
					if ring < rings - 1 then
						table.insert(edges, {curr, nextRing})
					end
				end
			end
			return edges
		end)()
	}
}

local function startOrbiting()
	if not selectedPart or not selectedPart.Parent then
		warn("No valid part selected!")
		return
	end
	
	-- Stop any existing orbit
	stopOrbiting()
	
	-- Update settings from textboxes
	orbitDistance = tonumber(distanceTextbox.Text) or 10
	orbitSpeed = tonumber(speedTextbox.Text) or 1
	gapValue = tonumber(gapTextbox.Text) or 2
	
	-- Find all unlocked unanchored parts
	for _, obj in ipairs(workspace:GetDescendants()) do
		if obj:IsA("BasePart") and obj ~= selectedPart then
			if isPartUnlocked(obj) and not obj.Anchored then
				table.insert(orbitingParts, obj)
				setNetworkOwnership(obj)
			end
		end
	end
	
	if #orbitingParts == 0 then
		warn("No unlocked unanchored parts found to orbit!")
		return
	end
	
	print("Orbiting " .. #orbitingParts .. " parts around " .. selectedPart.Name)
	print("Distance: " .. orbitDistance .. " studs, Speed: " .. orbitSpeed .. " studs/sec")
	print("Gap Mode: " .. gapMode)
	print("Orbit Shape: " .. orbitShape .. ", Animation: " .. animationMode)
	print("Wireframe Mode: " .. tostring(wireframeMode) .. (wireframeMode and (" - " .. wireframeShape) or ""))
	
	-- Orbit parameters for each part
	local orbitData = {}
	
	if wireframeMode then
		-- Wireframe mode: assign parts to edges of a 3D shape
		local shape = wireframeShapes[wireframeShape]
		
		for i, part in ipairs(orbitingParts) do
			local edgeIndex = ((i - 1) % #shape.edges) + 1
			local edge = shape.edges[edgeIndex]
			local vertexA = shape.vertices[edge[1]]
			local vertexB = shape.vertices[edge[2]]
			
			-- Position along the edge (0 to 1)
			local t = ((i - 1) / #shape.edges) % 1
			
			orbitData[part] = {
				wireframe = true,
				edgeIndex = edgeIndex,
				vertexA = vertexA,
				vertexB = vertexB,
				edgePosition = t,
				speed = orbitSpeed / orbitDistance,
				index = i
			}
		end
	else
		-- Normal orbit mode
		for i, part in ipairs(orbitingParts) do
			local radius = orbitDistance
			local speed = orbitSpeed / orbitDistance
			local baseAngle
			
			-- Apply gap mode adjustments
			if gapMode == "None" then
				-- Even distribution - perfect circle with no gaps
				baseAngle = (i / #orbitingParts) * math.pi * 2
			elseif gapMode == "GapPerPart" then
				-- Each part gets its own orbit ring further out
				radius = orbitDistance + ((i - 1) * gapValue)
				baseAngle = (i / #orbitingParts) * math.pi * 2
			elseif gapMode == "GapBetweenParts" then
				-- Distribute evenly with physical gap between parts
				-- Calculate the arc length each part needs (part size + gap)
				local arcLengthPerPart = gapValue
				local totalArcLength = arcLengthPerPart * #orbitingParts
				local requiredCircumference = totalArcLength
				
				-- Adjust radius to fit all parts with gaps
				radius = requiredCircumference / (2 * math.pi)
				
				-- Distribute angles evenly around the circle
				baseAngle = (i / #orbitingParts) * math.pi * 2
			end
			
			orbitData[part] = {
				wireframe = false,
				baseAngle = baseAngle,
				radius = radius,
				speed = speed,
				index = i,
				phaseOffset = math.random() * math.pi * 2
			}
		end
	end
	
	-- Position calculation function based on orbit shape
	local function calculatePosition(centerPos, angle, radius, height, time, index, total)
		local x, y, z = 0, 0, 0
		
		if orbitShape == "Circle" then
			x = math.cos(angle) * radius
			z = math.sin(angle) * radius
			y = height + math.sin(time * 2) * 2
			
		elseif orbitShape == "Sphere" then
			-- True 3D sphere distribution using spherical coordinates
			local phi = math.acos(1 - 2 * (index / total)) -- Polar angle
			local theta = angle -- Azimuthal angle
			x = radius * math.sin(phi) * math.cos(theta)
			y = radius * math.cos(phi)
			z = radius * math.sin(phi) * math.sin(theta)
			
		elseif orbitShape == "Cube" then
			local side = math.floor((index - 1) / (total / 6)) % 6
			local t = ((index - 1) % (total / 6)) / (total / 6)
			local size = radius
			
			if side == 0 then x, y, z = size, (t - 0.5) * 2 * size, math.sin(angle) * size
			elseif side == 1 then x, y, z = -size, (t - 0.5) * 2 * size, math.sin(angle) * size
			elseif side == 2 then x, y, z = (t - 0.5) * 2 * size, size, math.sin(angle) * size
			elseif side == 3 then x, y, z = (t - 0.5) * 2 * size, -size, math.sin(angle) * size
			elseif side == 4 then x, y, z = math.cos(angle) * size, (t - 0.5) * 2 * size, size
			else x, y, z = math.cos(angle) * size, (t - 0.5) * 2 * size, -size
			end
			
		elseif orbitShape == "Spiral" then
			local spiralHeight = (angle / (math.pi * 2)) * 10
			x = math.cos(angle) * radius
			z = math.sin(angle) * radius
			y = spiralHeight + height
			
		elseif orbitShape == "Wave" then
			x = math.cos(angle) * radius
			z = math.sin(angle) * radius
			y = height + math.sin(angle * 3 + time * 2) * 5
			
		elseif orbitShape == "Helix" then
			local helixRadius = radius * 0.7
			x = math.cos(angle) * helixRadius
			z = math.sin(angle) * helixRadius
			y = (angle / (math.pi * 2)) * 15 - 7.5 + math.sin(time * 2) * 3
			
		elseif orbitShape == "Figure8" then
			local scale = radius / 10
			x = math.sin(angle) * 10 * scale
			z = math.sin(angle * 2) * 10 * scale
			y = height + math.cos(time * 2) * 2
			
		elseif orbitShape == "Star" then
			local points = 5
			local outerRadius = radius
			local innerRadius = radius * 0.5
			local pointAngle = angle * points
			local r = (math.floor(pointAngle / (math.pi / points)) % 2 == 0) and outerRadius or innerRadius
			x = math.cos(angle) * r
			z = math.sin(angle) * r
			y = height + math.sin(time * 2) * 2
			
		elseif orbitShape == "Pentagon" then
			-- Perfect pentagon formation
			local sides = 5
			local sideIndex = math.floor((index - 1) % sides)
			local posOnSide = ((index - 1) % sides) + ((index - 1) / sides) % 1
			local perfectAngle = (sideIndex / sides) * math.pi * 2 - math.pi / 2
			x = math.cos(perfectAngle) * radius
			z = math.sin(perfectAngle) * radius
			y = height + math.sin(time * 2) * 2
			
		elseif orbitShape == "Hexagon" then
			-- Perfect hexagon formation
			local sides = 6
			local sideIndex = math.floor((index - 1) % sides)
			local perfectAngle = (sideIndex / sides) * math.pi * 2
			x = math.cos(perfectAngle) * radius
			z = math.sin(perfectAngle) * radius
			y = height + math.sin(time * 2) * 2
			
		elseif orbitShape == "Octagon" then
			-- Perfect octagon formation
			local sides = 8
			local sideIndex = math.floor((index - 1) % sides)
			local perfectAngle = (sideIndex / sides) * math.pi * 2
			x = math.cos(perfectAngle) * radius
			z = math.sin(perfectAngle) * radius
			y = height + math.sin(time * 2) * 2
			
		elseif orbitShape == "Diamond" then
			-- Diamond shape (4 pointed star in 3D)
			local t = (index / total) * 4
			local section = math.floor(t)
			local progress = t - section
			
			if section == 0 then
				x = progress * radius
				y = (1 - progress) * radius * 1.5
				z = 0
			elseif section == 1 then
				x = (1 - progress) * radius
				y = -progress * radius * 1.5
				z = 0
			elseif section == 2 then
				x = -progress * radius
				y = -(1 - progress) * radius * 1.5
				z = 0
			else
				x = -(1 - progress) * radius
				y = progress * radius * 1.5
				z = 0
			end
			y = y + height + math.sin(time * 2) * 2
			
		elseif orbitShape == "Heart" then
			-- Heart shape (parametric)
			local t = angle
			x = 16 * math.sin(t)^3 * (radius / 20)
			z = (13 * math.cos(t) - 5 * math.cos(2*t) - 2 * math.cos(3*t) - math.cos(4*t)) * (radius / 20)
			y = height + math.sin(time * 2) * 2
			
		elseif orbitShape == "Infinity" then
			-- Infinity symbol (lemniscate)
			local scale = radius / 3
			x = scale * math.cos(angle) / (1 + math.sin(angle)^2)
			z = scale * math.cos(angle) * math.sin(angle) / (1 + math.sin(angle)^2)
			y = height + math.sin(time * 2) * 2
			
		elseif orbitShape == "Flower" then
			-- Flower pattern (rose curve)
			local petals = 6
			local r = radius * math.cos(petals * angle)
			x = r * math.cos(angle)
			z = r * math.sin(angle)
			y = height + math.sin(time * 2 + angle * 2) * 3
			
		elseif orbitShape == "DNA" then
			-- DNA double helix
			local helixRadius = radius * 0.5
			local strand = (index % 2 == 0) and 1 or -1
			x = math.cos(angle + strand * math.pi) * helixRadius
			z = math.sin(angle + strand * math.pi) * helixRadius
			y = (angle / (math.pi * 2)) * 20 - 10
			
		elseif orbitShape == "Tornado" then
			-- Tornado/vortex shape
			local heightPos = (index / total) * 15 - 7.5
			local radiusAtHeight = radius * (1 - math.abs(heightPos) / 10)
			x = math.cos(angle + heightPos * 0.5) * radiusAtHeight
			z = math.sin(angle + heightPos * 0.5) * radiusAtHeight
			y = heightPos + height + math.sin(time * 3) * 2
			
		elseif orbitShape == "Galaxy" then
			-- Spiral galaxy arms
			local spiralAngle = angle + (index / total) * math.pi * 8
			local spiralRadius = radius * (0.3 + (index / total) * 0.7)
			x = math.cos(spiralAngle) * spiralRadius
			z = math.sin(spiralAngle) * spiralRadius
			y = height + math.sin(spiralAngle * 2) * 2 + math.cos(time * 2) * 1
			
		elseif orbitShape == "Rings" then
			-- Multiple concentric rings
			local ringIndex = math.floor((index - 1) / (total / 3))
			local ringRadius = radius * (0.5 + ringIndex * 0.3)
			local tilt = ringIndex * math.pi / 6
			local localX = math.cos(angle) * ringRadius
			local localZ = math.sin(angle) * ringRadius
			x = localX
			y = height + localZ * math.sin(tilt) + math.sin(time * 2) * 1
			z = localZ * math.cos(tilt)
			
		elseif orbitShape == "Mobius" then
			-- Mobius strip
			local u = angle
			local v = ((index / total) - 0.5) * 0.4
			local mobiusRadius = radius * 0.8
			x = (mobiusRadius + v * math.cos(u / 2)) * math.cos(u)
			y = v * math.sin(u / 2) + height + math.sin(time * 2) * 1
			z = (mobiusRadius + v * math.cos(u / 2)) * math.sin(u)
		end
		
		return centerPos + Vector3.new(x, y, z)
	end
	
	-- Wireframe position calculation
	local function calculateWireframePosition(centerPos, data, time)
		local shape = wireframeShapes[wireframeShape]
		local vertexA = data.vertexA * orbitDistance
		local vertexB = data.vertexB * orbitDistance
		
		-- Animate position along edge
		local t = (data.edgePosition + time * data.speed * 0.1) % 1
		local edgePos = vertexA:Lerp(vertexB, t)
		
		-- Rotate the entire shape
		local rotationAngle = time * data.speed * 0.5
		local rotatedPos = Vector3.new(
			edgePos.X * math.cos(rotationAngle) - edgePos.Z * math.sin(rotationAngle),
			edgePos.Y * math.cos(rotationAngle * 0.5),
			edgePos.X * math.sin(rotationAngle) + edgePos.Z * math.cos(rotationAngle)
		)
		
		return centerPos + rotatedPos
	end
	
	-- Orbit loop
	local startTime = tick()
	orbitConnection = RunService.Heartbeat:Connect(function(deltaTime)
		if not selectedPart or not selectedPart.Parent then
			stopOrbiting()
			return
		end
		
		local centerPos = selectedPart.Position
		local time = tick() - startTime
		
		for part, data in pairs(orbitData) do
			if part and part.Parent then
				local targetPos
				
				if data.wireframe then
					-- Wireframe mode
					targetPos = calculateWireframePosition(centerPos, data, time)
				else
					-- Normal orbit mode
					local currentAngle = data.baseAngle + (time * data.speed)
					targetPos = calculatePosition(
						centerPos, 
						currentAngle, 
						data.radius, 
						math.sin(data.baseAngle) * 3,
						time,
						data.index,
						#orbitingParts
					)
					
					-- Apply physics-based animations
					if animationMode == "Pulse" then
						local pulse = 1 + math.sin(time * 3 + data.phaseOffset) * 0.3
						local direction = (targetPos - centerPos).Unit
						targetPos = centerPos + direction * (targetPos - centerPos).Magnitude * pulse
						
					elseif animationMode == "Expand" then
						local expand = 1 + math.sin(time * 1.5) * 0.5
						local direction = (targetPos - centerPos).Unit
						targetPos = centerPos + direction * (targetPos - centerPos).Magnitude * expand
						
					elseif animationMode == "Wobble" then
						local wobbleX = math.sin(time * 4 + data.phaseOffset) * 2
						local wobbleY = math.cos(time * 3 + data.phaseOffset) * 2
						targetPos = targetPos + Vector3.new(wobbleX, wobbleY, 0)
						
					elseif animationMode == "Spin" then
						part.AssemblyAngularVelocity = Vector3.new(
							math.sin(time * 2) * 5,
							10,
							math.cos(time * 2) * 5
						)
						
					elseif animationMode == "Shake" then
						local shakeX = math.random(-1, 1) * 0.5
						local shakeY = math.random(-1, 1) * 0.5
						local shakeZ = math.random(-1, 1) * 0.5
						targetPos = targetPos + Vector3.new(shakeX, shakeY, shakeZ)
						
					elseif animationMode == "Bounce" then
						local bounceHeight = math.abs(math.sin(time * 5 + data.phaseOffset)) * 5
						targetPos = targetPos + Vector3.new(0, bounceHeight, 0)
						
					elseif animationMode == "Twist" then
						local twistAngle = math.sin(time * 2) * 0.5
						local direction = (targetPos - centerPos)
						local distance = direction.Magnitude
						local currentAngle = math.atan2(direction.Z, direction.X)
						local newAngle = currentAngle + twistAngle
						targetPos = centerPos + Vector3.new(
							math.cos(newAngle) * distance,
							direction.Y,
							math.sin(newAngle) * distance
						)
						
					elseif animationMode == "Orbit" then
						-- Parts orbit around their own position
						local orbitRadius = 2
						local orbitAngle = time * 3 + data.phaseOffset
						local orbitOffset = Vector3.new(
							math.cos(orbitAngle) * orbitRadius,
							math.sin(orbitAngle * 1.5) * orbitRadius,
							math.sin(orbitAngle) * orbitRadius
						)
						targetPos = targetPos + orbitOffset
						
					elseif animationMode == "Flip" then
						-- Flip parts end over end
						part.AssemblyAngularVelocity = Vector3.new(
							15 * math.sin(time + data.phaseOffset),
							5,
							15 * math.cos(time + data.phaseOffset)
						)
						
					elseif animationMode == "Stretch" then
						-- Stretch outward and contract
						local stretch = 1 + math.sin(time * 2 + data.phaseOffset) * 0.6
						local direction = (targetPos - centerPos).Unit
						local baseDistance = (targetPos - centerPos).Magnitude
						targetPos = centerPos + direction * baseDistance * stretch
						
					elseif animationMode == "Swirl" then
						-- Swirl around center with varying height
						local swirlAngle = time * 2
						local direction = (targetPos - centerPos)
						local distance = direction.Magnitude
						local currentAngle = math.atan2(direction.Z, direction.X)
						local newAngle = currentAngle + swirlAngle * 0.3
						targetPos = centerPos + Vector3.new(
							math.cos(newAngle) * distance,
							direction.Y + math.sin(time * 3 + data.phaseOffset) * 4,
							math.sin(newAngle) * distance
						)
						
					elseif animationMode == "Jitter" then
						-- Rapid jittery movement
						local jitterAmount = 1.5
						local jitterSpeed = 15
						local jitterX = math.sin(time * jitterSpeed + data.phaseOffset) * jitterAmount
						local jitterY = math.cos(time * jitterSpeed * 1.3 + data.phaseOffset) * jitterAmount
						local jitterZ = math.sin(time * jitterSpeed * 0.8 + data.phaseOffset) * jitterAmount
						targetPos = targetPos + Vector3.new(jitterX, jitterY, jitterZ)
						
					elseif animationMode == "Wave" then
						-- Wave motion through all parts
						local waveOffset = math.sin(time * 3 - (index / total) * math.pi * 2) * 5
						targetPos = targetPos + Vector3.new(0, waveOffset, 0)
					end
				end
				
				-- Apply velocity for smooth movement
				local currentPos = part.Position
				local direction = (targetPos - currentPos)
				local distance = direction.Magnitude
				
				if distance > 0.1 then
					part.AssemblyLinearVelocity = direction.Unit * math.min(distance * 5, 50)
				else
					part.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
				end
				
				-- Add rotation
				if animationMode ~= "Spin" then
					if data.wireframe then
						part.AssemblyAngularVelocity = Vector3.new(0, data.speed * 2, 0)
					else
						part.AssemblyAngularVelocity = Vector3.new(
							math.sin(time) * 0.5,
							data.speed * 2,
							math.cos(time) * 0.5
						)
					end
				end
			end
		end
	end)
	
	orbitButton.Text = "Stop Orbiting"
	orbitButton.BackgroundColor3 = Color3.fromRGB(120, 50, 50)
end

-- Button Events
selectionButton.MouseButton1Click:Connect(function()
	selectionMode = not selectionMode
	
	if selectionMode then
		selectionButton.Text = "Selection Mode: ON (Click Part)"
		selectionButton.BackgroundColor3 = Color3.fromRGB(50, 100, 150)
	else
		selectionButton.Text = "Enable Selection Mode"
		selectionButton.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
	end
end)

-- Hide Selection Box Toggle Event
hideSelectionToggle.MouseButton1Click:Connect(function()
	hideSelectionBox = not hideSelectionBox
	
	if hideSelectionBox then
		hideSelectionToggle.Text = "Hide Selection Box: ON"
		hideSelectionToggle.BackgroundColor3 = Color3.fromRGB(50, 100, 150)
		-- Remove existing selection box if present
		if selectionBox then
			selectionBox:Destroy()
			selectionBox = nil
		end
	else
		hideSelectionToggle.Text = "Hide Selection Box: OFF"
		hideSelectionToggle.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
		-- Recreate selection box if part is selected
		if selectedPart and selectedPart.Parent then
			createSelectionBox(selectedPart)
		end
	end
end)

-- Gap Mode Button Events
local function updateGapModeButtons(selectedMode)
	gapMode = selectedMode
	gapModeLabel.Text = "Gap Mode: " .. gapMode
	
	gapModeNone.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
	gapModePerPart.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
	gapModeBetween.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
	
	if selectedMode == "None" then
		gapModeNone.BackgroundColor3 = Color3.fromRGB(50, 100, 50)
	elseif selectedMode == "GapPerPart" then
		gapModePerPart.BackgroundColor3 = Color3.fromRGB(50, 100, 50)
	elseif selectedMode == "GapBetweenParts" then
		gapModeBetween.BackgroundColor3 = Color3.fromRGB(50, 100, 50)
	end
end

gapModeNone.MouseButton1Click:Connect(function() updateGapModeButtons("None") end)
gapModePerPart.MouseButton1Click:Connect(function() updateGapModeButtons("GapPerPart") end)
gapModeBetween.MouseButton1Click:Connect(function() updateGapModeButtons("GapBetweenParts") end)

-- Orbit Shape Button Events
local shapeButtons = {shapeCircle, shapeSphere, shapeCube, shapeSpiral, shapeWave, shapeHelix, shapeFigure8, shapeStar, shapePentagon, shapeHexagon, shapeOctagon, shapeDiamond, shapeHeart, shapeInfinity, shapeFlower, shapeDNA, shapeTornado, shapeGalaxy, shapeRings, shapeMobius}

local function updateOrbitShape(selectedShape, buttonClicked)
	orbitShape = selectedShape
	shapeLabel.Text = "Orbit Shape: " .. orbitShape
	
	for _, btn in ipairs(shapeButtons) do
		btn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
	end
	
	buttonClicked.BackgroundColor3 = Color3.fromRGB(50, 100, 50)
end

shapeCircle.MouseButton1Click:Connect(function() updateOrbitShape("Circle", shapeCircle) end)
shapeSphere.MouseButton1Click:Connect(function() updateOrbitShape("Sphere", shapeSphere) end)
shapeCube.MouseButton1Click:Connect(function() updateOrbitShape("Cube", shapeCube) end)
shapeSpiral.MouseButton1Click:Connect(function() updateOrbitShape("Spiral", shapeSpiral) end)
shapeWave.MouseButton1Click:Connect(function() updateOrbitShape("Wave", shapeWave) end)
shapeHelix.MouseButton1Click:Connect(function() updateOrbitShape("Helix", shapeHelix) end)
shapeFigure8.MouseButton1Click:Connect(function() updateOrbitShape("Figure8", shapeFigure8) end)
shapeStar.MouseButton1Click:Connect(function() updateOrbitShape("Star", shapeStar) end)
shapePentagon.MouseButton1Click:Connect(function() updateOrbitShape("Pentagon", shapePentagon) end)
shapeHexagon.MouseButton1Click:Connect(function() updateOrbitShape("Hexagon", shapeHexagon) end)
shapeOctagon.MouseButton1Click:Connect(function() updateOrbitShape("Octagon", shapeOctagon) end)
shapeDiamond.MouseButton1Click:Connect(function() updateOrbitShape("Diamond", shapeDiamond) end)
shapeHeart.MouseButton1Click:Connect(function() updateOrbitShape("Heart", shapeHeart) end)
shapeInfinity.MouseButton1Click:Connect(function() updateOrbitShape("Infinity", shapeInfinity) end)
shapeFlower.MouseButton1Click:Connect(function() updateOrbitShape("Flower", shapeFlower) end)
shapeDNA.MouseButton1Click:Connect(function() updateOrbitShape("DNA", shapeDNA) end)
shapeTornado.MouseButton1Click:Connect(function() updateOrbitShape("Tornado", shapeTornado) end)
shapeGalaxy.MouseButton1Click:Connect(function() updateOrbitShape("Galaxy", shapeGalaxy) end)
shapeRings.MouseButton1Click:Connect(function() updateOrbitShape("Rings", shapeRings) end)
shapeMobius.MouseButton1Click:Connect(function() updateOrbitShape("Mobius", shapeMobius) end)

-- Animation Mode Button Events
local animButtons = {animNone, animPulse, animExpand, animWobble, animSpin, animShake, animBounce, animTwist, animOrbit, animFlip, animStretch, animSwirl, animJitter, animWaveAnim}

local function updateAnimationMode(selectedAnim, buttonClicked)
	animationMode = selectedAnim
	animLabel.Text = "Animation: " .. animationMode
	
	for _, btn in ipairs(animButtons) do
		btn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
	end
	
	buttonClicked.BackgroundColor3 = Color3.fromRGB(50, 100, 50)
end

animNone.MouseButton1Click:Connect(function() updateAnimationMode("None", animNone) end)
animPulse.MouseButton1Click:Connect(function() updateAnimationMode("Pulse", animPulse) end)
animExpand.MouseButton1Click:Connect(function() updateAnimationMode("Expand", animExpand) end)
animWobble.MouseButton1Click:Connect(function() updateAnimationMode("Wobble", animWobble) end)
animSpin.MouseButton1Click:Connect(function() updateAnimationMode("Spin", animSpin) end)
animShake.MouseButton1Click:Connect(function() updateAnimationMode("Shake", animShake) end)
animBounce.MouseButton1Click:Connect(function() updateAnimationMode("Bounce", animBounce) end)
animTwist.MouseButton1Click:Connect(function() updateAnimationMode("Twist", animTwist) end)
animOrbit.MouseButton1Click:Connect(function() updateAnimationMode("Orbit", animOrbit) end)
animFlip.MouseButton1Click:Connect(function() updateAnimationMode("Flip", animFlip) end)
animStretch.MouseButton1Click:Connect(function() updateAnimationMode("Stretch", animStretch) end)
animSwirl.MouseButton1Click:Connect(function() updateAnimationMode("Swirl", animSwirl) end)
animJitter.MouseButton1Click:Connect(function() updateAnimationMode("Jitter", animJitter) end)
animWaveAnim.MouseButton1Click:Connect(function() updateAnimationMode("Wave", animWaveAnim) end)

-- Wireframe Toggle Event
wireframeToggle.MouseButton1Click:Connect(function()
	wireframeMode = not wireframeMode
	if wireframeMode then
		wireframeLabel.Text = "Wireframe Mode: ON - " .. wireframeShape
		wireframeToggle.BackgroundColor3 = Color3.fromRGB(100, 50, 150)
	else
		wireframeLabel.Text = "Wireframe Mode: OFF"
		wireframeToggle.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
	end
end)

-- Wireframe Shape Button Events
local wireframeButtons = {wireframeCube, wireframePyramid, wireframeOcta, wireframeTetra, wireframeIco, wireframeTorus, wireframeCylinder, wireframeDodeca, wireframeSphere}

local function updateWireframeShape(selectedShape, buttonClicked)
	wireframeShape = selectedShape
	if wireframeMode then
		wireframeLabel.Text = "Wireframe Mode: ON - " .. wireframeShape
	end
	
	for _, btn in ipairs(wireframeButtons) do
		btn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
	end
	
	buttonClicked.BackgroundColor3 = Color3.fromRGB(50, 100, 50)
end

wireframeCube.MouseButton1Click:Connect(function() updateWireframeShape("Cube", wireframeCube) end)
wireframePyramid.MouseButton1Click:Connect(function() updateWireframeShape("Pyramid", wireframePyramid) end)
wireframeOcta.MouseButton1Click:Connect(function() updateWireframeShape("Octahedron", wireframeOcta) end)
wireframeTetra.MouseButton1Click:Connect(function() updateWireframeShape("Tetrahedron", wireframeTetra) end)
wireframeIco.MouseButton1Click:Connect(function() updateWireframeShape("Icosahedron", wireframeIco) end)
wireframeTorus.MouseButton1Click:Connect(function() updateWireframeShape("Torus", wireframeTorus) end)
wireframeCylinder.MouseButton1Click:Connect(function() updateWireframeShape("Cylinder", wireframeCylinder) end)
wireframeDodeca.MouseButton1Click:Connect(function() updateWireframeShape("Dodecahedron", wireframeDodeca) end)
wireframeSphere.MouseButton1Click:Connect(function() updateWireframeShape("Sphere", wireframeSphere) end)

-- Hammer Mode Events
hammerToggle.MouseButton1Click:Connect(function()
	if hammerMode then
		destroyHammer()
	else
		createHammer()
	end
end)

hammerSmash.MouseButton1Click:Connect(function()
	smashHammer()
end)

-- M key binding for hammer smash
UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed then return end
	
	if input.KeyCode == Enum.KeyCode.M then
		if hammerMode then
			smashHammer()
		end
	end
end)

orbitButton.MouseButton1Click:Connect(function()
	if orbitConnection then
		stopOrbiting()
	else
		startOrbiting()
	end
end)

-- Mouse Click for Selection
mouse.Button1Down:Connect(function()
	if not selectionMode then return end
	
	local target = mouse.Target
	if target and isPartUnlocked(target) then
		selectPart(target)
	end
end)

-- Cleanup on character death
player.CharacterAdded:Connect(function()
	stopOrbiting()
	clearSelection()
	destroyHammer()
end)

print("ðŸŒŸ ULTIMATE Orbit Parts Script with TONS of Features! ðŸŒŸ")
print("Instructions:")
print("1. Click 'Enable Selection Mode'")
print("2. Click on an unlocked part to select it")
print("3. Adjust orbit distance, speed, and gap settings")
print("4. Choose from 20 ORBIT SHAPES!")
print("5. Apply 14 DIFFERENT ANIMATIONS!")
print("6. Toggle Wireframe Mode for 9 3D shapes")
print("7. Create 3D Hammer (16x16x3 studs) - positioned 4 studs beside block")
print("8. Hammer follows block rotation on X and Z axes")
print("9. Press M or click 'SMASH GROUND' - unused parts EXPLODE at impact!")
print("")
print("âœ¨âœ¨ NEW FEATURES âœ¨âœ¨")
print("ðŸ”· 20 ORBIT SHAPES:")
print("   Circle, Sphere, Cube, Spiral, Wave, Helix, Figure 8, Star")
print("   Pentagon, Hexagon, Octagon, Diamond, Heart, Infinity")
print("   Flower, DNA, Tornado, Galaxy, Rings, Mobius")
print("")
print("ðŸŽ­ 14 ANIMATIONS:")
print("   Pulse, Expand, Wobble, Spin, Shake, Bounce, Twist")
print("   Orbit, Flip, Stretch, Swirl, Jitter, Wave")
print("")
print("ðŸ”² 9 WIREFRAME 3D SHAPES:")
print("   Cube, Pyramid, Octahedron, Tetrahedron, Icosahedron")
print("   Torus, Cylinder, Dodecahedron, Sphere")
print("")
print("ðŸ”¨ 3D Hammer with depth - follows block rotation")
print("ðŸ’¥ Ground Impact - hammer smashes down, parts explode at impact zone!")
print("ðŸ‘ï¸ Hide Selection Box toggle - enjoy unobstructed views!")
print("ðŸ“ Perfect Polygon Formation - parts auto-arrange perfectly")
